"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@solana-mobile+wallet-adapter-mobile@2.1.4_@solana+web3.js@1.98.0_bufferutil@4.0.8_utf-8-vali_jvmmv2csvzpookyrzhnufdtjlm";
exports.ids = ["vendor-chunks/@solana-mobile+wallet-adapter-mobile@2.1.4_@solana+web3.js@1.98.0_bufferutil@4.0.8_utf-8-vali_jvmmv2csvzpookyrzhnufdtjlm"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@solana-mobile+wallet-adapter-mobile@2.1.4_@solana+web3.js@1.98.0_bufferutil@4.0.8_utf-8-vali_jvmmv2csvzpookyrzhnufdtjlm/node_modules/@solana-mobile/wallet-adapter-mobile/lib/esm/index.js":
/*!************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@solana-mobile+wallet-adapter-mobile@2.1.4_@solana+web3.js@1.98.0_bufferutil@4.0.8_utf-8-vali_jvmmv2csvzpookyrzhnufdtjlm/node_modules/@solana-mobile/wallet-adapter-mobile/lib/esm/index.js ***!
  \************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SolanaMobileWalletAdapter: () => (/* binding */ SolanaMobileWalletAdapter),\n/* harmony export */   SolanaMobileWalletAdapterRemote: () => (/* binding */ SolanaMobileWalletAdapterRemote),\n/* harmony export */   SolanaMobileWalletAdapterRemoteWalletName: () => (/* binding */ SolanaMobileWalletAdapterRemoteWalletName),\n/* harmony export */   SolanaMobileWalletAdapterWalletName: () => (/* binding */ SolanaMobileWalletAdapterWalletName),\n/* harmony export */   createDefaultAddressSelector: () => (/* binding */ createDefaultAddressSelector),\n/* harmony export */   createDefaultAuthorizationResultCache: () => (/* binding */ createDefaultAuthorizationResultCache),\n/* harmony export */   createDefaultWalletNotFoundHandler: () => (/* binding */ createDefaultWalletNotFoundHandler)\n/* harmony export */ });\n/* harmony import */ var _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @solana/wallet-adapter-base */ \"(ssr)/./node_modules/.pnpm/@solana+wallet-adapter-base@0.9.23_@solana+web3.js@1.98.0_bufferutil@4.0.8_utf-8-validate@5.0.10_/node_modules/@solana/wallet-adapter-base/lib/esm/signer.js\");\n/* harmony import */ var _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @solana/wallet-adapter-base */ \"(ssr)/./node_modules/.pnpm/@solana+wallet-adapter-base@0.9.23_@solana+web3.js@1.98.0_bufferutil@4.0.8_utf-8-validate@5.0.10_/node_modules/@solana/wallet-adapter-base/lib/esm/adapter.js\");\n/* harmony import */ var _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @solana/wallet-adapter-base */ \"(ssr)/./node_modules/.pnpm/@solana+wallet-adapter-base@0.9.23_@solana+web3.js@1.98.0_bufferutil@4.0.8_utf-8-validate@5.0.10_/node_modules/@solana/wallet-adapter-base/lib/esm/errors.js\");\n/* harmony import */ var _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @solana/wallet-adapter-base */ \"(ssr)/./node_modules/.pnpm/@solana+wallet-adapter-base@0.9.23_@solana+web3.js@1.98.0_bufferutil@4.0.8_utf-8-validate@5.0.10_/node_modules/@solana/wallet-adapter-base/lib/esm/transaction.js\");\n/* harmony import */ var _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @solana/web3.js */ \"(ssr)/./node_modules/.pnpm/@solana+web3.js@1.98.0_bufferutil@4.0.8_utf-8-validate@5.0.10/node_modules/@solana/web3.js/lib/index.esm.js\");\n/* harmony import */ var _solana_mobile_mobile_wallet_adapter_protocol_web3js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @solana-mobile/mobile-wallet-adapter-protocol-web3js */ \"(ssr)/./node_modules/.pnpm/@solana-mobile+mobile-wallet-adapter-protocol-web3js@2.1.4_@solana+wallet-adapter-base@0.9.23_ovjye32esay3iiqc4ns6yxjmly/node_modules/@solana-mobile/mobile-wallet-adapter-protocol-web3js/lib/esm/index.js\");\n/* harmony import */ var qrcode__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! qrcode */ \"(ssr)/./node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/index.js\");\n/* harmony import */ var js_base64__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! js-base64 */ \"(ssr)/./node_modules/.pnpm/js-base64@3.7.7/node_modules/js-base64/base64.mjs\");\n\n\n\n\n\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\n\nfunction toUint8Array(base64EncodedByteArray) {\n    return new Uint8Array(window\n        .atob(base64EncodedByteArray)\n        .split('')\n        .map((c) => c.charCodeAt(0)));\n}\n\nfunction getIsSupported$1() {\n    return (typeof window !== 'undefined' &&\n        window.isSecureContext &&\n        typeof document !== 'undefined' &&\n        /android/i.test(navigator.userAgent));\n}\n\nconst SolanaMobileWalletAdapterWalletName = 'Mobile Wallet Adapter';\nconst SIGNATURE_LENGTH_IN_BYTES$1 = 64;\nfunction getPublicKeyFromAddress$1(address) {\n    const publicKeyByteArray = toUint8Array(address);\n    return new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.PublicKey(publicKeyByteArray);\n}\nfunction isVersionedTransaction(transaction) {\n    return 'version' in transaction;\n}\nfunction clusterToChainId(cluster) {\n    switch (cluster) {\n        case 'mainnet-beta':\n            return 'solana:mainnet';\n        case 'testnet':\n            return 'solana:testnet';\n        case 'devnet':\n            return 'solana:devnet';\n    }\n}\nclass SolanaMobileWalletAdapter extends _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.BaseSignInMessageSignerWalletAdapter {\n    constructor(config) {\n        var _a;\n        super();\n        this.supportedTransactionVersions = new Set(\n        // FIXME(#244): We can't actually know what versions are supported until we know which wallet we're talking to.\n        ['legacy', 0]);\n        this.name = SolanaMobileWalletAdapterWalletName;\n        this.url = 'https://solanamobile.com/wallets';\n        this.icon = 'data:image/svg+xml;base64,PHN2ZyBmaWxsPSJub25lIiBoZWlnaHQ9IjI4IiB3aWR0aD0iMjgiIHZpZXdCb3g9Ii0zIDAgMjggMjgiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgZmlsbD0iI0RDQjhGRiI+PHBhdGggZD0iTTE3LjQgMTcuNEgxNXYyLjRoMi40di0yLjRabTEuMi05LjZoLTIuNHYyLjRoMi40VjcuOFoiLz48cGF0aCBkPSJNMjEuNiAzVjBoLTIuNHYzaC0zLjZWMGgtMi40djNoLTIuNHY2LjZINC41YTIuMSAyLjEgMCAxIDEgMC00LjJoMi43VjNINC41QTQuNSA0LjUgMCAwIDAgMCA3LjVWMjRoMjEuNnYtNi42aC0yLjR2NC4ySDIuNFYxMS41Yy41LjMgMS4yLjQgMS44LjVoNy41QTYuNiA2LjYgMCAwIDAgMjQgOVYzaC0yLjRabTAgNS43YTQuMiA0LjIgMCAxIDEtOC40IDBWNS40aDguNHYzLjNaIi8+PC9nPjwvc3ZnPg==';\n        this._connecting = false;\n        /**\n         * Every time the connection is recycled in some way (eg. `disconnect()` is called)\n         * increment this and use it to make sure that `transact` calls from the previous\n         * 'generation' don't continue to do work and throw exceptions.\n         */\n        this._connectionGeneration = 0;\n        this._readyState = getIsSupported$1() ? _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_4__.WalletReadyState.Loadable : _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_4__.WalletReadyState.Unsupported;\n        this._authorizationResultCache = config.authorizationResultCache;\n        this._addressSelector = config.addressSelector;\n        this._appIdentity = config.appIdentity;\n        this._chain = (_a = config.chain) !== null && _a !== void 0 ? _a : clusterToChainId(config.cluster);\n        this._hostAuthority = config.remoteHostAuthority;\n        this._onWalletNotFound = config.onWalletNotFound;\n        if (this._readyState !== _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_4__.WalletReadyState.Unsupported) {\n            this._authorizationResultCache.get().then((authorizationResult) => {\n                if (authorizationResult) {\n                    // Having a prior authorization result is, right now, the best\n                    // indication that a mobile wallet is installed. There is no API\n                    // we can use to test for whether the association URI is supported.\n                    this.declareWalletAsInstalled();\n                }\n            });\n        }\n    }\n    get publicKey() {\n        if (this._publicKey == null && this._selectedAddress != null) {\n            try {\n                this._publicKey = getPublicKeyFromAddress$1(this._selectedAddress);\n            }\n            catch (e) {\n                throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_5__.WalletPublicKeyError((e instanceof Error && (e === null || e === void 0 ? void 0 : e.message)) || 'Unknown error', e);\n            }\n        }\n        return this._publicKey ? this._publicKey : null;\n    }\n    get connected() {\n        return !!this._authorizationResult;\n    }\n    get connecting() {\n        return this._connecting;\n    }\n    get readyState() {\n        return this._readyState;\n    }\n    declareWalletAsInstalled() {\n        if (this._readyState !== _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_4__.WalletReadyState.Installed) {\n            this.emit('readyStateChange', (this._readyState = _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_4__.WalletReadyState.Installed));\n        }\n    }\n    runWithGuard(callback) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                return yield callback();\n            }\n            catch (e) {\n                this.emit('error', e);\n                throw e;\n            }\n        });\n    }\n    /** @deprecated Use `autoConnect()` instead. */\n    autoConnect_DO_NOT_USE_OR_YOU_WILL_BE_FIRED() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return yield this.autoConnect();\n        });\n    }\n    autoConnect() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.connecting || this.connected) {\n                return;\n            }\n            return yield this.runWithGuard(() => __awaiter(this, void 0, void 0, function* () {\n                if (this._readyState !== _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_4__.WalletReadyState.Installed && this._readyState !== _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_4__.WalletReadyState.Loadable) {\n                    throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_5__.WalletNotReadyError();\n                }\n                this._connecting = true;\n                try {\n                    const cachedAuthorizationResult = yield this._authorizationResultCache.get();\n                    if (cachedAuthorizationResult) {\n                        // TODO: Evaluate whether there's any threat to not `awaiting` this expression\n                        this.handleAuthorizationResult(cachedAuthorizationResult);\n                    }\n                }\n                catch (e) {\n                    throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_5__.WalletConnectionError((e instanceof Error && e.message) || 'Unknown error', e);\n                }\n                finally {\n                    this._connecting = false;\n                }\n            }));\n        });\n    }\n    connect() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.connecting || this.connected) {\n                return;\n            }\n            return yield this.runWithGuard(() => __awaiter(this, void 0, void 0, function* () {\n                if (this._readyState !== _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_4__.WalletReadyState.Installed && this._readyState !== _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_4__.WalletReadyState.Loadable) {\n                    throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_5__.WalletNotReadyError();\n                }\n                this._connecting = true;\n                try {\n                    yield this.performAuthorization();\n                }\n                catch (e) {\n                    throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_5__.WalletConnectionError((e instanceof Error && e.message) || 'Unknown error', e);\n                }\n                finally {\n                    this._connecting = false;\n                }\n            }));\n        });\n    }\n    performAuthorization(signInPayload) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const cachedAuthorizationResult = yield this._authorizationResultCache.get();\n                if (cachedAuthorizationResult) {\n                    // TODO: Evaluate whether there's any threat to not `awaiting` this expression\n                    this.handleAuthorizationResult(cachedAuthorizationResult);\n                    return cachedAuthorizationResult;\n                }\n                return yield this.transact((wallet) => __awaiter(this, void 0, void 0, function* () {\n                    const authorizationResult = yield wallet.authorize({\n                        chain: this._chain,\n                        identity: this._appIdentity,\n                        sign_in_payload: signInPayload,\n                    });\n                    // TODO: Evaluate whether there's any threat to not `awaiting` this expression\n                    Promise.all([\n                        this._authorizationResultCache.set(authorizationResult),\n                        this.handleAuthorizationResult(authorizationResult),\n                    ]);\n                    return authorizationResult;\n                }));\n            }\n            catch (e) {\n                throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_5__.WalletConnectionError((e instanceof Error && e.message) || 'Unknown error', e);\n            }\n        });\n    }\n    handleAuthorizationResult(authorizationResult) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            const didPublicKeysChange = \n            // Case 1: We started from having no authorization.\n            this._authorizationResult == null ||\n                // Case 2: The number of authorized accounts changed.\n                ((_a = this._authorizationResult) === null || _a === void 0 ? void 0 : _a.accounts.length) !== authorizationResult.accounts.length ||\n                // Case 3: The new list of addresses isn't exactly the same as the old list, in the same order.\n                this._authorizationResult.accounts.some((account, ii) => account.address !== authorizationResult.accounts[ii].address);\n            this._authorizationResult = authorizationResult;\n            this.declareWalletAsInstalled();\n            if (didPublicKeysChange) {\n                const nextSelectedAddress = yield this._addressSelector.select(authorizationResult.accounts.map(({ address }) => address));\n                if (nextSelectedAddress !== this._selectedAddress) {\n                    this._selectedAddress = nextSelectedAddress;\n                    delete this._publicKey;\n                    this.emit('connect', \n                    // Having just set `this._selectedAddress`, `this.publicKey` is definitely non-null\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    this.publicKey);\n                }\n            }\n        });\n    }\n    performReauthorization(wallet, authToken) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const authorizationResult = yield wallet.authorize({\n                    auth_token: authToken,\n                    identity: this._appIdentity,\n                });\n                // TODO: Evaluate whether there's any threat to not `awaiting` this expression\n                Promise.all([\n                    this._authorizationResultCache.set(authorizationResult),\n                    this.handleAuthorizationResult(authorizationResult),\n                ]);\n            }\n            catch (e) {\n                this.disconnect();\n                throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_5__.WalletDisconnectedError((e instanceof Error && (e === null || e === void 0 ? void 0 : e.message)) || 'Unknown error', e);\n            }\n        });\n    }\n    disconnect() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this._authorizationResultCache.clear(); // TODO: Evaluate whether there's any threat to not `awaiting` this expression\n            this._connecting = false;\n            this._connectionGeneration++;\n            delete this._authorizationResult;\n            delete this._publicKey;\n            delete this._selectedAddress;\n            this.emit('disconnect');\n        });\n    }\n    transact(callback) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            const walletUriBase = (_a = this._authorizationResult) === null || _a === void 0 ? void 0 : _a.wallet_uri_base;\n            const config = walletUriBase ? { baseUri: walletUriBase } : undefined;\n            const remoteConfig = this._hostAuthority ? { remoteHostAuthority: this._hostAuthority } : undefined;\n            const currentConnectionGeneration = this._connectionGeneration;\n            try {\n                return yield (0,_solana_mobile_mobile_wallet_adapter_protocol_web3js__WEBPACK_IMPORTED_MODULE_1__.transact)(callback, Object.assign(Object.assign({}, config), remoteConfig));\n            }\n            catch (e) {\n                if (this._connectionGeneration !== currentConnectionGeneration) {\n                    yield new Promise(() => { }); // Never resolve.\n                }\n                if (e instanceof Error &&\n                    e.name === 'SolanaMobileWalletAdapterError' &&\n                    e.code === 'ERROR_WALLET_NOT_FOUND') {\n                    yield this._onWalletNotFound(this);\n                }\n                throw e;\n            }\n        });\n    }\n    assertIsAuthorized() {\n        if (!this._authorizationResult || !this._selectedAddress)\n            throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_5__.WalletNotConnectedError();\n        return {\n            authToken: this._authorizationResult.auth_token,\n            selectedAddress: this._selectedAddress,\n        };\n    }\n    performSignTransactions(transactions) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const { authToken } = this.assertIsAuthorized();\n            try {\n                return yield this.transact((wallet) => __awaiter(this, void 0, void 0, function* () {\n                    yield this.performReauthorization(wallet, authToken);\n                    const signedTransactions = yield wallet.signTransactions({\n                        transactions,\n                    });\n                    return signedTransactions;\n                }));\n            }\n            catch (error) {\n                throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_5__.WalletSignTransactionError(error === null || error === void 0 ? void 0 : error.message, error);\n            }\n        });\n    }\n    sendTransaction(transaction, connection, options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return yield this.runWithGuard(() => __awaiter(this, void 0, void 0, function* () {\n                const { authToken } = this.assertIsAuthorized();\n                const minContextSlot = options === null || options === void 0 ? void 0 : options.minContextSlot;\n                try {\n                    return yield this.transact((wallet) => __awaiter(this, void 0, void 0, function* () {\n                        function getTargetCommitment() {\n                            let targetCommitment;\n                            switch (connection.commitment) {\n                                case 'confirmed':\n                                case 'finalized':\n                                case 'processed':\n                                    targetCommitment = connection.commitment;\n                                    break;\n                                default:\n                                    targetCommitment = 'finalized';\n                            }\n                            let targetPreflightCommitment;\n                            switch (options === null || options === void 0 ? void 0 : options.preflightCommitment) {\n                                case 'confirmed':\n                                case 'finalized':\n                                case 'processed':\n                                    targetPreflightCommitment = options.preflightCommitment;\n                                    break;\n                                case undefined:\n                                    targetPreflightCommitment = targetCommitment;\n                                    break;\n                                default:\n                                    targetPreflightCommitment = 'finalized';\n                            }\n                            const preflightCommitmentScore = targetPreflightCommitment === 'finalized'\n                                ? 2\n                                : targetPreflightCommitment === 'confirmed'\n                                    ? 1\n                                    : 0;\n                            const targetCommitmentScore = targetCommitment === 'finalized' ? 2 : targetCommitment === 'confirmed' ? 1 : 0;\n                            return preflightCommitmentScore < targetCommitmentScore\n                                ? targetPreflightCommitment\n                                : targetCommitment;\n                        }\n                        const [capabilities, _1, _2] = yield Promise.all([\n                            wallet.getCapabilities(),\n                            this.performReauthorization(wallet, authToken),\n                            isVersionedTransaction(transaction)\n                                ? null\n                                : /**\n                                   * Unlike versioned transactions, legacy `Transaction` objects\n                                   * may not have an associated `feePayer` or `recentBlockhash`.\n                                   * This code exists to patch them up in case they are missing.\n                                   */\n                                    (() => __awaiter(this, void 0, void 0, function* () {\n                                        var _a;\n                                        transaction.feePayer || (transaction.feePayer = (_a = this.publicKey) !== null && _a !== void 0 ? _a : undefined);\n                                        if (transaction.recentBlockhash == null) {\n                                            const { blockhash } = yield connection.getLatestBlockhash({\n                                                commitment: getTargetCommitment(),\n                                            });\n                                            transaction.recentBlockhash = blockhash;\n                                        }\n                                    }))(),\n                        ]);\n                        if (capabilities.supports_sign_and_send_transactions) {\n                            const signatures = yield wallet.signAndSendTransactions({\n                                minContextSlot,\n                                transactions: [transaction],\n                            });\n                            return signatures[0];\n                        }\n                        else {\n                            const [signedTransaction] = yield wallet.signTransactions({\n                                transactions: [transaction],\n                            });\n                            if (isVersionedTransaction(signedTransaction)) {\n                                return yield connection.sendTransaction(signedTransaction);\n                            }\n                            else {\n                                const serializedTransaction = signedTransaction.serialize();\n                                return yield connection.sendRawTransaction(serializedTransaction, Object.assign(Object.assign({}, options), { preflightCommitment: getTargetCommitment() }));\n                            }\n                        }\n                    }));\n                }\n                catch (error) {\n                    throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_5__.WalletSendTransactionError(error === null || error === void 0 ? void 0 : error.message, error);\n                }\n            }));\n        });\n    }\n    signTransaction(transaction) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return yield this.runWithGuard(() => __awaiter(this, void 0, void 0, function* () {\n                const [signedTransaction] = yield this.performSignTransactions([transaction]);\n                return signedTransaction;\n            }));\n        });\n    }\n    signAllTransactions(transactions) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return yield this.runWithGuard(() => __awaiter(this, void 0, void 0, function* () {\n                const signedTransactions = yield this.performSignTransactions(transactions);\n                return signedTransactions;\n            }));\n        });\n    }\n    signMessage(message) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return yield this.runWithGuard(() => __awaiter(this, void 0, void 0, function* () {\n                const { authToken, selectedAddress } = this.assertIsAuthorized();\n                try {\n                    return yield this.transact((wallet) => __awaiter(this, void 0, void 0, function* () {\n                        yield this.performReauthorization(wallet, authToken);\n                        const [signedMessage] = yield wallet.signMessages({\n                            addresses: [selectedAddress],\n                            payloads: [message],\n                        });\n                        const signature = signedMessage.slice(-SIGNATURE_LENGTH_IN_BYTES$1);\n                        return signature;\n                    }));\n                }\n                catch (error) {\n                    throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_5__.WalletSignMessageError(error === null || error === void 0 ? void 0 : error.message, error);\n                }\n            }));\n        });\n    }\n    signIn(input) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return yield this.runWithGuard(() => __awaiter(this, void 0, void 0, function* () {\n                var _a, _b;\n                if (this._readyState !== _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_4__.WalletReadyState.Installed && this._readyState !== _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_4__.WalletReadyState.Loadable) {\n                    throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_5__.WalletNotReadyError();\n                }\n                this._connecting = true;\n                try {\n                    const authorizationResult = yield this.performAuthorization(Object.assign(Object.assign({}, input), { domain: (_a = input === null || input === void 0 ? void 0 : input.domain) !== null && _a !== void 0 ? _a : window.location.host }));\n                    if (!authorizationResult.sign_in_result) {\n                        throw new Error(\"Sign in failed, no sign in result returned by wallet\");\n                    }\n                    const signedInAddress = authorizationResult.sign_in_result.address;\n                    const signedInAccount = Object.assign(Object.assign({}, (_b = authorizationResult.accounts.find(acc => acc.address == signedInAddress)) !== null && _b !== void 0 ? _b : {\n                        address: signedInAddress\n                    }), { publicKey: toUint8Array(signedInAddress) });\n                    return {\n                        account: signedInAccount,\n                        signedMessage: toUint8Array(authorizationResult.sign_in_result.signed_message),\n                        signature: toUint8Array(authorizationResult.sign_in_result.signature)\n                    };\n                }\n                catch (e) {\n                    throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_5__.WalletConnectionError((e instanceof Error && e.message) || 'Unknown error', e);\n                }\n                finally {\n                    this._connecting = false;\n                }\n            }));\n        });\n    }\n}\n\nconst BluetoothHtml = `\r\n    <div class=\"mobile-wallet-adapter-embedded-modal-content\">\r\n    <button id=\"mobile-wallet-adapter-embedded-modal-close\" class=\"mobile-wallet-adapter-embedded-modal-close\">\r\n        <svg width=\"14\" height=\"14\">\r\n        <path d=\"M14 12.461 8.3 6.772l5.234-5.233L12.006 0 6.772 5.234 1.54 0 0 1.539l5.234 5.233L0 12.006l1.539 1.528L6.772 8.3l5.69 5.7L14 12.461z\" />\r\n        </svg>\r\n    </button>\r\n    <h1><b>Jupiter</b> wants to connect</h1>\r\n    <p class=\"mobile-wallet-adapter-embedded-modal-subtitle\">Connect to your mobile wallet app through Bluetooth.</p>\r\n    <div class=\"mobile-wallet-adapter-embedded-modal-connection-status-container\">\r\n        <div id=\"status-not-connected\" class=\"connection-status\">\r\n        <svg class=\"bluetooth-icon\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\">\r\n            <path fill=\"#a0a0a0\" d=\"M14.24 12.01l2.32 2.32c.28-.72.44-1.51.44-2.33 0-.82-.16-1.59-.43-2.31l-2.33 2.32zm5.29-5.3l-1.26 1.26c.63 1.21.98 2.57.98 4.02s-.36 2.82-.98 4.02l1.2 1.2c.97-1.54 1.54-3.36 1.54-5.31-.01-1.89-.55-3.67-1.48-5.19zm-3.82 1L10 2H9v7.59L4.41 5 3 6.41 8.59 12 3 17.59 4.41 19 9 14.41V22h1l5.71-5.71-4.3-4.29 4.3-4.29zM11 5.83l1.88 1.88L11 9.59V5.83zm1.88 10.46L11 18.17v-3.76l1.88 1.88z\"/>\r\n        </svg>\r\n        <p>Not connected</p>\r\n        </div>\r\n        <div id=\"status-connecting\" class=\"connection-status\" style=\"display:none;\">\r\n        <div class=\"spinner\"></div>\r\n        <p>Connecting...</p>\r\n        </div>\r\n        <div id=\"status-connected\" class=\"connection-status\" style=\"display:none;\">\r\n        <svg class=\"checkmark-icon\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\">\r\n            <path fill=\"#4CAF50\" d=\"M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z\"/>\r\n        </svg>\r\n        <p>Connected</p>\r\n        </div>\r\n    </div>\r\n    <div class=\"button-group\">\r\n        <button id=\"cancel-btn\" class=\"cancel-btn\">Cancel</button>\r\n        <button id=\"connect-btn\" class=\"connect-btn\">Connect</button>\r\n    </div>\r\n    </div>\r\n`;\n\nconst QRCodeHtml = `\r\n<div class=\"mobile-wallet-adapter-embedded-modal-content\">\r\n  <button id=\"mobile-wallet-adapter-embedded-modal-close\" class=\"mobile-wallet-adapter-embedded-modal-close\">\r\n    <svg width=\"14\" height=\"14\">\r\n      <path d=\"M14 12.461 8.3 6.772l5.234-5.233L12.006 0 6.772 5.234 1.54 0 0 1.539l5.234 5.233L0 12.006l1.539 1.528L6.772 8.3l5.69 5.7L14 12.461z\" />\r\n    </svg>\r\n  </button>\r\n  <h1>Scan to connect</h1>\r\n  <p class=\"mobile-wallet-adapter-embedded-modal-subtitle\">Use your wallet app to scan the QR Code and connect.</p>\r\n  <div id=\"mobile-wallet-adapter-embedded-modal-qr-code-container\" />\r\n</div>\r\n`;\n\nconst css = `\r\n.mobile-wallet-adapter-embedded-modal {\r\n    display: flex; /* Use flexbox to center content */\r\n    flex-direction: column;\r\n    justify-content: center; /* Center horizontally */\r\n    align-items: center; /* Center vertically */\r\n    position: fixed; /* Stay in place */\r\n    z-index: 1; /* Sit on top */\r\n    left: 0;\r\n    top: 0;\r\n    width: 100%; /* Full width */\r\n    height: 100%; /* Full height */\r\n    background-color: rgba(0,0,0,0.4); /* Black w/ opacity */\r\n}\r\n\r\n.mobile-wallet-adapter-embedded-modal-content {\r\n    background: #10141f;\r\n    padding: 20px;\r\n    border-radius: 10px;\r\n    width: 80%;\r\n    max-width: 500px;\r\n    text-align: center;\r\n    position: relative;\r\n    display: flex;\r\n    flex-direction: column;\r\n    align-items: center; /* Center children horizontally */\r\n}\r\n\r\n.mobile-wallet-adapter-embedded-modal-subtitle {\r\n    color: #D8D8D8;\r\n}\r\n\r\n.mobile-wallet-adapter-embedded-modal-close {\r\n    display: flex;\r\n    align-items: center;\r\n    justify-content: center;\r\n    position: absolute;\r\n    top: 18px;\r\n    right: 18px;\r\n    padding: 12px;\r\n    cursor: pointer;\r\n    background: #1a1f2e;\r\n    border: none;\r\n    border-radius: 50%;\r\n}\r\n\r\n.mobile-wallet-adapter-embedded-modal-close:focus-visible {\r\n    outline-color: white;\r\n}\r\n\r\n.mobile-wallet-adapter-embedded-modal-close svg {\r\n    fill: #777;\r\n    transition: fill 200ms ease 0s;\r\n}\r\n\r\n.mobile-wallet-adapter-embedded-modal-close:hover svg {\r\n    fill: #fff;\r\n}\r\n\r\n.icon-container {\r\n    display: flex;\r\n    justify-content: center;\r\n    margin-bottom: 20px;\r\n}\r\n\r\n.icon {\r\n    width: 80px;\r\n    height: 80px;\r\n    border-radius: 50%;\r\n    background-color: #ddd; /* Placeholder for icon background */\r\n}\r\n\r\n/* Modal Title */\r\n.mobile-wallet-adapter-embedded-modal-content h1 {\r\n    color: white;\r\n    font-size: 24px;   \r\n}\r\n\r\n.button-group {\r\n    display: flex;\r\n    width: 100%;\r\n    gap: 10px;\r\n}\r\n\r\n.connect-btn, .cancel-btn {\r\n    flex: 1;\r\n    padding: 12px 20px;\r\n    font-size: 16px;\r\n    cursor: pointer;\r\n    border-radius: 10px;\r\n    transition: all 0.3s ease;\r\n}\r\n\r\n.connect-btn {\r\n    background-color: #007bff;\r\n    color: white;\r\n    border: none;\r\n}\r\n\r\n.connect-btn:hover {\r\n    background-color: #0056b3;\r\n}\r\n\r\n.cancel-btn {\r\n    background-color: transparent;\r\n    color: #a0a0a0;\r\n    border: 1px solid #a0a0a0;\r\n}\r\n\r\n.cancel-btn:hover {\r\n    background-color: rgba(160, 160, 160, 0.1);\r\n}\r\n\r\n/* BT Connection Status */\r\n\r\n.mobile-wallet-adapter-embedded-modal-connection-status-container {\r\n    margin: 20px 0px 20px 0px;\r\n}\r\n\r\n.connection-status {\r\n    display: flex;\r\n    flex-direction: column;\r\n    align-items: center;\r\n    justify-content: center;\r\n    margin: 20px 0;\r\n}\r\n  \r\n.connection-status p {\r\n    margin-top: 10px;\r\n    color: #a0a0a0;\r\n}\r\n  \r\n.bluetooth-icon, .checkmark-icon {\r\n    width: 48px;\r\n    height: 48px;\r\n}\r\n  \r\n.spinner {\r\n    border: 4px solid #f3f3f3;\r\n    border-top: 4px solid #3498db;\r\n    border-radius: 50%;\r\n    width: 40px;\r\n    height: 40px;\r\n    animation: spin 1s linear infinite;\r\n}\r\n  \r\n@keyframes spin {\r\n    0% { transform: rotate(0deg); }\r\n    100% { transform: rotate(360deg); }\r\n}\r\n\r\n/* QR Code */\r\n\r\n#mobile-wallet-adapter-embedded-modal-qr-code-container {\r\n    width: 500px;\r\n    height: 500px;\r\n    align-content: center;\r\n}\r\n`;\n\nclass EmbeddedModal {\n    constructor(title) {\n        this._root = null;\n        this._title = title;\n        // Bind methods to ensure `this` context is correct\n        this.init = this.init.bind(this);\n        this.injectQRCodeHTML = this.injectQRCodeHTML.bind(this);\n        this.injectBluetoothHTML = this.injectBluetoothHTML.bind(this);\n        this.open = this.open.bind(this);\n        this.close = this.close.bind(this);\n        this.connect = this.connect.bind(this);\n        this._root = document.getElementById('mobile-wallet-adapter-embedded-root-ui');\n    }\n    init(qrCode) {\n        return __awaiter(this, void 0, void 0, function* () {\n            console.log('Injecting modal');\n            this.injectStyles();\n            this.injectQRCodeHTML(qrCode);\n        });\n    }\n    setConnectionStatus(status) {\n        if (!this._root)\n            return;\n        const statuses = ['not-connected', 'connecting', 'connected'];\n        statuses.forEach((s) => {\n            const el = this._root.querySelector(`#status-${s}`);\n            if (el instanceof HTMLElement) {\n                el.style.display = s === status ? 'flex' : 'none';\n            }\n        });\n    }\n    injectStyles() {\n        // Check if the styles have already been injected\n        if (document.getElementById('mobile-wallet-adapter-styles')) {\n            return;\n        }\n        const styleElement = document.createElement('style');\n        styleElement.id = 'mobile-wallet-adapter-styles';\n        styleElement.textContent = css;\n        document.head.appendChild(styleElement);\n    }\n    populateQRCode(qrUrl) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const qrcodeContainer = document.getElementById('mobile-wallet-adapter-embedded-modal-qr-code-container');\n            if (qrcodeContainer) {\n                const qrCodeElement = yield qrcode__WEBPACK_IMPORTED_MODULE_2__.toCanvas(qrUrl, { width: 400 });\n                if (qrcodeContainer.firstElementChild !== null) {\n                    qrcodeContainer.replaceChild(qrCodeElement, qrcodeContainer.firstElementChild);\n                }\n                else\n                    qrcodeContainer.appendChild(qrCodeElement);\n            }\n            else {\n                console.error('QRCode Container not found');\n            }\n        });\n    }\n    injectQRCodeHTML(qrCode) {\n        // Check if the HTML has already been injected\n        if (document.getElementById('mobile-wallet-adapter-embedded-root-ui')) {\n            if (!this._root)\n                this._root = document.getElementById('mobile-wallet-adapter-embedded-root-ui');\n            this.populateQRCode(qrCode);\n            return;\n        }\n        // Create a container for the modal\n        this._root = document.createElement('div');\n        this._root.id = 'mobile-wallet-adapter-embedded-root-ui';\n        this._root.className = 'mobile-wallet-adapter-embedded-modal';\n        this._root.innerHTML = QRCodeHtml;\n        this._root.style.display = 'none';\n        // Append the modal to the body\n        document.body.appendChild(this._root);\n        // Render the QRCode\n        this.populateQRCode(qrCode);\n        this.attachEventListeners();\n    }\n    injectBluetoothHTML() {\n        // Check if the HTML has already been injected\n        if (document.getElementById('mobile-wallet-adapter-embedded-root-ui')) {\n            return;\n        }\n        this._root = document.createElement('div');\n        this._root.id = 'mobile-wallet-adapter-embedded-root-ui';\n        this._root.className = 'mobile-wallet-adapter-embedded-modal';\n        this._root.innerHTML = BluetoothHtml;\n        document.body.appendChild(this._root);\n        this.attachEventListeners();\n    }\n    attachEventListeners() {\n        if (!this._root)\n            return;\n        const closeBtn = this._root.querySelector('#mobile-wallet-adapter-embedded-modal-close');\n        const cancelBtn = this._root.querySelector('#cancel-btn');\n        const connectBtn = this._root.querySelector('#connect-btn');\n        closeBtn === null || closeBtn === void 0 ? void 0 : closeBtn.addEventListener('click', () => this.close());\n        cancelBtn === null || cancelBtn === void 0 ? void 0 : cancelBtn.addEventListener('click', () => this.close());\n        connectBtn === null || connectBtn === void 0 ? void 0 : connectBtn.addEventListener('click', () => this.connect());\n    }\n    open() {\n        console.debug('Modal open');\n        if (this._root) {\n            this._root.style.display = 'flex';\n            this.setConnectionStatus('not-connected'); // Reset status when opening\n        }\n    }\n    close() {\n        console.debug('Modal close');\n        if (this._root) {\n            this._root.style.display = 'none';\n            this.setConnectionStatus('not-connected'); // Reset status when closing\n        }\n    }\n    connect() {\n        console.log('Connecting...');\n        // Mock connection\n        this.setConnectionStatus('connecting');\n        // Simulate connection process\n        setTimeout(() => {\n            this.setConnectionStatus('connected');\n            console.log('Connected!');\n        }, 5000); // 5 seconds delay\n    }\n}\n\nconst SolanaMobileWalletAdapterRemoteWalletName = 'MWA (Remote)';\nconst SIGNATURE_LENGTH_IN_BYTES = 64;\nfunction getPublicKeyFromAddress(address) {\n    const publicKeyByteArray = (0,js_base64__WEBPACK_IMPORTED_MODULE_6__.toUint8Array)(address);\n    return new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.PublicKey(publicKeyByteArray);\n}\n/**\n * Determine the mobile operating system.\n * Returns true if running on a mobile operating system, or false otherwise.\n *\n * @returns {boolean}\n */\nfunction isMobileOperatingSystem() {\n    var userAgent = navigator.userAgent;\n    // Windows Phone must come first because its UA also contains \"Android\"\n    if (/windows phone/i.test(userAgent)) {\n        return true;\n    }\n    if (/android/i.test(userAgent)) {\n        return true;\n    }\n    // iOS detection from: http://stackoverflow.com/a/9039885/177710\n    if (/iPad|iPhone|iPod/.test(userAgent) && !window.MSStream) {\n        return true;\n    }\n    return false;\n}\nfunction getIsSupported() {\n    return (typeof window !== 'undefined' &&\n        window.isSecureContext &&\n        typeof document !== 'undefined' &&\n        !isMobileOperatingSystem());\n}\n/**\n * This burner wallet adapter is unsafe to use and is only included to provide an easy way for applications to test\n * Wallet Adapter without using a third-party wallet.\n */\nclass SolanaMobileWalletAdapterRemote extends _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.BaseSignInMessageSignerWalletAdapter {\n    constructor(config) {\n        super();\n        this.supportedTransactionVersions = new Set(\n        // FIXME(#244): We can't actually know what versions are supported until we know which wallet we're talking to.\n        ['legacy', 0]);\n        this.name = SolanaMobileWalletAdapterRemoteWalletName;\n        this.url = 'https://solanamobile.com/wallets';\n        this.icon = 'data:image/svg+xml;base64,PHN2ZyBmaWxsPSJub25lIiBoZWlnaHQ9IjI4IiB3aWR0aD0iMjgiIHZpZXdCb3g9Ii0zIDAgMjggMjgiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgZmlsbD0iI0RDQjhGRiI+PHBhdGggZD0iTTE3LjQgMTcuNEgxNXYyLjRoMi40di0yLjRabTEuMi05LjZoLTIuNHYyLjRoMi40VjcuOFoiLz48cGF0aCBkPSJNMjEuNiAzVjBoLTIuNHYzaC0zLjZWMGgtMi40djNoLTIuNHY2LjZINC41YTIuMSAyLjEgMCAxIDEgMC00LjJoMi43VjNINC41QTQuNSA0LjUgMCAwIDAgMCA3LjVWMjRoMjEuNnYtNi42aC0yLjR2NC4ySDIuNFYxMS41Yy41LjMgMS4yLjQgMS44LjVoNy41QTYuNiA2LjYgMCAwIDAgMjQgOVYzaC0yLjRabTAgNS43YTQuMiA0LjIgMCAxIDEtOC40IDBWNS40aDguNHYzLjNaIi8+PC9nPjwvc3ZnPg==';\n        this._connecting = false;\n        /**\n         * Every time the connection is recycled in some way (eg. `disconnect()` is called)\n         * increment this and use it to make sure that `transact` calls from the previous\n         * 'generation' don't continue to do work and throw exceptions.\n         */\n        this._connectionGeneration = 0;\n        this._readyState = getIsSupported() ? _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_4__.WalletReadyState.Loadable : _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_4__.WalletReadyState.Unsupported;\n        this._authorizationResultCache = config.authorizationResultCache;\n        this._addressSelector = config.addressSelector;\n        this._appIdentity = config.appIdentity;\n        this._chain = config.chain;\n        this._hostAuthority = config.remoteHostAuthority;\n        this._onWalletNotFound = config.onWalletNotFound;\n        if (this._readyState !== _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_4__.WalletReadyState.Unsupported) {\n            this._authorizationResultCache.get().then((authorizationResult) => {\n                if (authorizationResult) {\n                    // Having a prior authorization result is, right now, the best\n                    // indication that a mobile wallet is installed. There is no API\n                    // we can use to test for whether the association URI is supported.\n                    this.declareWalletAsInstalled();\n                }\n            });\n        }\n    }\n    get publicKey() {\n        if (this._publicKey == null && this._selectedAddress != null) {\n            try {\n                this._publicKey = getPublicKeyFromAddress(this._selectedAddress);\n            }\n            catch (e) {\n                throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_5__.WalletPublicKeyError((e instanceof Error && (e === null || e === void 0 ? void 0 : e.message)) || 'Unknown error', e);\n            }\n        }\n        return this._publicKey ? this._publicKey : null;\n    }\n    get connected() {\n        return !!this._authorizationResult;\n    }\n    get connecting() {\n        return this._connecting;\n    }\n    get readyState() {\n        return this._readyState;\n    }\n    declareWalletAsInstalled() {\n        if (this._readyState !== _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_4__.WalletReadyState.Installed) {\n            this.emit('readyStateChange', (this._readyState = _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_4__.WalletReadyState.Installed));\n        }\n    }\n    runWithGuard(callback) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                return yield callback();\n            }\n            catch (e) {\n                this.emit('error', e);\n                throw e;\n            }\n        });\n    }\n    autoConnect() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.connecting || this.connected) {\n                return;\n            }\n            return yield this.runWithGuard(() => __awaiter(this, void 0, void 0, function* () {\n                if (this._readyState !== _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_4__.WalletReadyState.Installed && this._readyState !== _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_4__.WalletReadyState.Loadable) {\n                    throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_5__.WalletNotReadyError();\n                }\n                this._connecting = true;\n                try {\n                    const cachedAuthorizationResult = yield this._authorizationResultCache.get();\n                    if (cachedAuthorizationResult) {\n                        // TODO: Evaluate whether there's any threat to not `awaiting` this expression\n                        this.handleAuthorizationResult(cachedAuthorizationResult);\n                    }\n                }\n                catch (e) {\n                    throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_5__.WalletConnectionError((e instanceof Error && e.message) || 'Unknown error', e);\n                }\n                finally {\n                    this._connecting = false;\n                }\n            }));\n        });\n    }\n    connect() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.connecting || this.connected) {\n                return;\n            }\n            return yield this.runWithGuard(() => __awaiter(this, void 0, void 0, function* () {\n                if (this._readyState !== _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_4__.WalletReadyState.Installed && this._readyState !== _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_4__.WalletReadyState.Loadable) {\n                    throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_5__.WalletNotReadyError();\n                }\n                this._connecting = true;\n                try {\n                    yield this.performAuthorization();\n                }\n                catch (e) {\n                    throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_5__.WalletConnectionError((e instanceof Error && e.message) || 'Unknown error', e);\n                }\n                finally {\n                    this._connecting = false;\n                }\n            }));\n        });\n    }\n    performAuthorization(signInPayload) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const cachedAuthorizationResult = yield this._authorizationResultCache.get();\n                if (cachedAuthorizationResult) {\n                    // TODO: Evaluate whether there's any threat to not `awaiting` this expression\n                    this.handleAuthorizationResult(cachedAuthorizationResult);\n                    return cachedAuthorizationResult;\n                }\n                if (this._wallet)\n                    delete this._wallet;\n                return yield this.transact((wallet) => __awaiter(this, void 0, void 0, function* () {\n                    this._wallet = wallet;\n                    const authorizationResult = yield wallet.authorize({\n                        chain: this._chain,\n                        identity: this._appIdentity,\n                        sign_in_payload: signInPayload,\n                    });\n                    // TODO: Evaluate whether there's any threat to not `awaiting` this expression\n                    Promise.all([\n                        this._authorizationResultCache.set(authorizationResult),\n                        this.handleAuthorizationResult(authorizationResult),\n                    ]);\n                    return authorizationResult;\n                }));\n            }\n            catch (e) {\n                throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_5__.WalletConnectionError((e instanceof Error && e.message) || 'Unknown error', e);\n            }\n        });\n    }\n    handleAuthorizationResult(authorizationResult) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            const didPublicKeysChange = \n            // Case 1: We started from having no authorization.\n            this._authorizationResult == null ||\n                // Case 2: The number of authorized accounts changed.\n                ((_a = this._authorizationResult) === null || _a === void 0 ? void 0 : _a.accounts.length) !== authorizationResult.accounts.length ||\n                // Case 3: The new list of addresses isn't exactly the same as the old list, in the same order.\n                this._authorizationResult.accounts.some((account, ii) => account.address !== authorizationResult.accounts[ii].address);\n            this._authorizationResult = authorizationResult;\n            this.declareWalletAsInstalled();\n            if (didPublicKeysChange) {\n                const nextSelectedAddress = yield this._addressSelector.select(authorizationResult.accounts.map(({ address }) => address));\n                if (nextSelectedAddress !== this._selectedAddress) {\n                    this._selectedAddress = nextSelectedAddress;\n                    delete this._publicKey;\n                    this.emit('connect', \n                    // Having just set `this._selectedAddress`, `this.publicKey` is definitely non-null\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    this.publicKey);\n                }\n            }\n        });\n    }\n    performReauthorization(wallet, authToken) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const authorizationResult = yield wallet.authorize({\n                    auth_token: authToken,\n                    identity: this._appIdentity,\n                });\n                // TODO: Evaluate whether there's any threat to not `awaiting` this expression\n                Promise.all([\n                    this._authorizationResultCache.set(authorizationResult),\n                    this.handleAuthorizationResult(authorizationResult),\n                ]);\n            }\n            catch (e) {\n                this.disconnect();\n                throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_5__.WalletDisconnectedError((e instanceof Error && (e === null || e === void 0 ? void 0 : e.message)) || 'Unknown error', e);\n            }\n        });\n    }\n    disconnect() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            // TODO: figure out why this call throws \"TypeError: _a.terminateSession is not a function\"\n            //  even though the session termination is actually executed (websocket closes). \n            try {\n                (_a = this._wallet) === null || _a === void 0 ? void 0 : _a.terminateSession();\n            }\n            catch (e) { }\n            this._authorizationResultCache.clear(); // TODO: Evaluate whether there's any threat to not `awaiting` this expression\n            this._connecting = false;\n            this._connectionGeneration++;\n            delete this._authorizationResult;\n            delete this._publicKey;\n            delete this._selectedAddress;\n            delete this._wallet;\n            this.emit('disconnect');\n        });\n    }\n    transact(callback) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            const walletUriBase = (_a = this._authorizationResult) === null || _a === void 0 ? void 0 : _a.wallet_uri_base;\n            const baseConfig = walletUriBase ? { baseUri: walletUriBase } : undefined;\n            const remoteConfig = Object.assign(Object.assign({}, baseConfig), { remoteHostAuthority: this._hostAuthority });\n            const currentConnectionGeneration = this._connectionGeneration;\n            const modal = new EmbeddedModal('MWA QR');\n            if (this._wallet) {\n                return callback(this._wallet);\n            }\n            try {\n                const { associationUrl, result: promise } = yield (0,_solana_mobile_mobile_wallet_adapter_protocol_web3js__WEBPACK_IMPORTED_MODULE_1__.transactRemote)((wallet) => __awaiter(this, void 0, void 0, function* () {\n                    const result = yield callback(wallet);\n                    modal.close();\n                    return result;\n                }), remoteConfig);\n                modal.init(associationUrl.toString());\n                modal.open();\n                return yield promise;\n            }\n            catch (e) {\n                modal.close();\n                if (this._connectionGeneration !== currentConnectionGeneration) {\n                    yield new Promise(() => { }); // Never resolve.\n                }\n                if (e instanceof Error &&\n                    e.name === 'SolanaMobileWalletAdapterError' &&\n                    e.code === 'ERROR_WALLET_NOT_FOUND') {\n                    yield this._onWalletNotFound(this);\n                }\n                throw e;\n            }\n        });\n    }\n    assertIsAuthorized() {\n        if (!this._authorizationResult || !this._selectedAddress)\n            throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_5__.WalletNotConnectedError();\n        return {\n            authToken: this._authorizationResult.auth_token,\n            selectedAddress: this._selectedAddress,\n        };\n    }\n    performSignTransactions(transactions) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const { authToken } = this.assertIsAuthorized();\n            try {\n                return yield this.transact((wallet) => __awaiter(this, void 0, void 0, function* () {\n                    yield this.performReauthorization(wallet, authToken);\n                    const signedTransactions = yield wallet.signTransactions({\n                        transactions,\n                    });\n                    return signedTransactions;\n                }));\n            }\n            catch (error) {\n                throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_5__.WalletSignTransactionError(error === null || error === void 0 ? void 0 : error.message, error);\n            }\n        });\n    }\n    sendTransaction(transaction, connection, options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return yield this.runWithGuard(() => __awaiter(this, void 0, void 0, function* () {\n                const { authToken } = this.assertIsAuthorized();\n                const minContextSlot = options === null || options === void 0 ? void 0 : options.minContextSlot;\n                try {\n                    return yield this.transact((wallet) => __awaiter(this, void 0, void 0, function* () {\n                        function getTargetCommitment() {\n                            let targetCommitment;\n                            switch (connection.commitment) {\n                                case 'confirmed':\n                                case 'finalized':\n                                case 'processed':\n                                    targetCommitment = connection.commitment;\n                                    break;\n                                default:\n                                    targetCommitment = 'finalized';\n                            }\n                            let targetPreflightCommitment;\n                            switch (options === null || options === void 0 ? void 0 : options.preflightCommitment) {\n                                case 'confirmed':\n                                case 'finalized':\n                                case 'processed':\n                                    targetPreflightCommitment = options.preflightCommitment;\n                                    break;\n                                case undefined:\n                                    targetPreflightCommitment = targetCommitment;\n                                    break;\n                                default:\n                                    targetPreflightCommitment = 'finalized';\n                            }\n                            const preflightCommitmentScore = targetPreflightCommitment === 'finalized'\n                                ? 2\n                                : targetPreflightCommitment === 'confirmed'\n                                    ? 1\n                                    : 0;\n                            const targetCommitmentScore = targetCommitment === 'finalized' ? 2 : targetCommitment === 'confirmed' ? 1 : 0;\n                            return preflightCommitmentScore < targetCommitmentScore\n                                ? targetPreflightCommitment\n                                : targetCommitment;\n                        }\n                        const [capabilities, _1, _2] = yield Promise.all([\n                            wallet.getCapabilities(),\n                            this.performReauthorization(wallet, authToken),\n                            (0,_solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_7__.isVersionedTransaction)(transaction)\n                                ? null\n                                : /**\n                                   * Unlike versioned transactions, legacy `Transaction` objects\n                                   * may not have an associated `feePayer` or `recentBlockhash`.\n                                   * This code exists to patch them up in case they are missing.\n                                   */\n                                    (() => __awaiter(this, void 0, void 0, function* () {\n                                        var _a;\n                                        transaction.feePayer || (transaction.feePayer = (_a = this.publicKey) !== null && _a !== void 0 ? _a : undefined);\n                                        if (transaction.recentBlockhash == null) {\n                                            const { blockhash } = yield connection.getLatestBlockhash({\n                                                commitment: getTargetCommitment(),\n                                            });\n                                            transaction.recentBlockhash = blockhash;\n                                        }\n                                    }))(),\n                        ]);\n                        if (capabilities.supports_sign_and_send_transactions) {\n                            const signatures = yield wallet.signAndSendTransactions({\n                                minContextSlot,\n                                transactions: [transaction],\n                            });\n                            return signatures[0];\n                        }\n                        else {\n                            const [signedTransaction] = yield wallet.signTransactions({\n                                transactions: [transaction],\n                            });\n                            if ((0,_solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_7__.isVersionedTransaction)(signedTransaction)) {\n                                return yield connection.sendTransaction(signedTransaction);\n                            }\n                            else {\n                                const serializedTransaction = signedTransaction.serialize();\n                                return yield connection.sendRawTransaction(serializedTransaction, Object.assign(Object.assign({}, options), { preflightCommitment: getTargetCommitment() }));\n                            }\n                        }\n                    }));\n                }\n                catch (error) {\n                    throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_5__.WalletSendTransactionError(error === null || error === void 0 ? void 0 : error.message, error);\n                }\n            }));\n        });\n    }\n    signTransaction(transaction) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return yield this.runWithGuard(() => __awaiter(this, void 0, void 0, function* () {\n                const [signedTransaction] = yield this.performSignTransactions([transaction]);\n                return signedTransaction;\n            }));\n        });\n    }\n    signAllTransactions(transactions) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return yield this.runWithGuard(() => __awaiter(this, void 0, void 0, function* () {\n                const signedTransactions = yield this.performSignTransactions(transactions);\n                return signedTransactions;\n            }));\n        });\n    }\n    signMessage(message) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return yield this.runWithGuard(() => __awaiter(this, void 0, void 0, function* () {\n                const { authToken, selectedAddress } = this.assertIsAuthorized();\n                try {\n                    return yield this.transact((wallet) => __awaiter(this, void 0, void 0, function* () {\n                        yield this.performReauthorization(wallet, authToken);\n                        const [signedMessage] = yield wallet.signMessages({\n                            addresses: [selectedAddress],\n                            payloads: [message],\n                        });\n                        const signature = signedMessage.slice(-SIGNATURE_LENGTH_IN_BYTES);\n                        return signature;\n                    }));\n                }\n                catch (error) {\n                    throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_5__.WalletSignMessageError(error === null || error === void 0 ? void 0 : error.message, error);\n                }\n            }));\n        });\n    }\n    signIn(input) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return yield this.runWithGuard(() => __awaiter(this, void 0, void 0, function* () {\n                var _a, _b;\n                if (this._readyState !== _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_4__.WalletReadyState.Installed && this._readyState !== _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_4__.WalletReadyState.Loadable) {\n                    throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_5__.WalletNotReadyError();\n                }\n                this._connecting = true;\n                try {\n                    const authorizationResult = yield this.performAuthorization(Object.assign(Object.assign({}, input), { domain: (_a = input === null || input === void 0 ? void 0 : input.domain) !== null && _a !== void 0 ? _a : window.location.host }));\n                    if (!authorizationResult.sign_in_result) {\n                        throw new Error(\"Sign in failed, no sign in result returned by wallet\");\n                    }\n                    const signedInAddress = authorizationResult.sign_in_result.address;\n                    const signedInAccount = Object.assign(Object.assign({}, (_b = authorizationResult.accounts.find(acc => acc.address == signedInAddress)) !== null && _b !== void 0 ? _b : {\n                        address: signedInAddress\n                    }), { publicKey: (0,js_base64__WEBPACK_IMPORTED_MODULE_6__.toUint8Array)(signedInAddress) });\n                    return {\n                        account: signedInAccount,\n                        signedMessage: (0,js_base64__WEBPACK_IMPORTED_MODULE_6__.toUint8Array)(authorizationResult.sign_in_result.signed_message),\n                        signature: (0,js_base64__WEBPACK_IMPORTED_MODULE_6__.toUint8Array)(authorizationResult.sign_in_result.signature)\n                    };\n                }\n                catch (e) {\n                    throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_5__.WalletConnectionError((e instanceof Error && e.message) || 'Unknown error', e);\n                }\n                finally {\n                    this._connecting = false;\n                }\n            }));\n        });\n    }\n}\n\nfunction createDefaultAddressSelector() {\n    return {\n        select(addresses) {\n            return __awaiter(this, void 0, void 0, function* () {\n                return addresses[0];\n            });\n        },\n    };\n}\n\nconst CACHE_KEY = 'SolanaMobileWalletAdapterDefaultAuthorizationCache';\nfunction createDefaultAuthorizationResultCache() {\n    let storage;\n    try {\n        storage = window.localStorage;\n        // eslint-disable-next-line no-empty\n    }\n    catch (_a) { }\n    return {\n        clear() {\n            return __awaiter(this, void 0, void 0, function* () {\n                if (!storage) {\n                    return;\n                }\n                try {\n                    storage.removeItem(CACHE_KEY);\n                    // eslint-disable-next-line no-empty\n                }\n                catch (_a) { }\n            });\n        },\n        get() {\n            return __awaiter(this, void 0, void 0, function* () {\n                if (!storage) {\n                    return;\n                }\n                try {\n                    return JSON.parse(storage.getItem(CACHE_KEY)) || undefined;\n                    // eslint-disable-next-line no-empty\n                }\n                catch (_a) { }\n            });\n        },\n        set(authorizationResult) {\n            return __awaiter(this, void 0, void 0, function* () {\n                if (!storage) {\n                    return;\n                }\n                try {\n                    storage.setItem(CACHE_KEY, JSON.stringify(authorizationResult));\n                    // eslint-disable-next-line no-empty\n                }\n                catch (_a) { }\n            });\n        },\n    };\n}\n\nfunction defaultWalletNotFoundHandler(mobileWalletAdapter) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (typeof window !== 'undefined') {\n            window.location.assign(mobileWalletAdapter.url);\n        }\n    });\n}\nfunction createDefaultWalletNotFoundHandler() {\n    return defaultWalletNotFoundHandler;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHNvbGFuYS1tb2JpbGUrd2FsbGV0LWFkYXB0ZXItbW9iaWxlQDIuMS40X0Bzb2xhbmErd2ViMy5qc0AxLjk4LjBfYnVmZmVydXRpbEA0LjAuOF91dGYtOC12YWxpX2p2bW12MmNzdnpwb29reXJ6aG51ZmR0amxtL25vZGVfbW9kdWxlcy9Ac29sYW5hLW1vYmlsZS93YWxsZXQtYWRhcHRlci1tb2JpbGUvbGliL2VzbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBNlY7QUFDalQ7QUFDb0Q7QUFDcEU7QUFDK0I7O0FBRTNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLCtEQUErRCxpQkFBaUI7QUFDNUc7QUFDQSxvQ0FBb0MsTUFBTSwrQkFBK0IsWUFBWTtBQUNyRixtQ0FBbUMsTUFBTSxtQ0FBbUMsWUFBWTtBQUN4RixnQ0FBZ0M7QUFDaEM7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsc0RBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3Qyw2RkFBb0M7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCx5RUFBZ0IsWUFBWSx5RUFBZ0I7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLHlFQUFnQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELEVBQUU7QUFDN0Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0Qyw0Q0FBZSxVQUFVLFlBQVk7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxTQUFTO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsK0JBQStC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QTs7QUFFK1AiLCJzb3VyY2VzIjpbIi93b3Jrc3BhY2VzL3N0YWtlLXRvLWVhcm4tdWkvbm9kZV9tb2R1bGVzLy5wbnBtL0Bzb2xhbmEtbW9iaWxlK3dhbGxldC1hZGFwdGVyLW1vYmlsZUAyLjEuNF9Ac29sYW5hK3dlYjMuanNAMS45OC4wX2J1ZmZlcnV0aWxANC4wLjhfdXRmLTgtdmFsaV9qdm1tdjJjc3Z6cG9va3lyemhudWZkdGpsbS9ub2RlX21vZHVsZXMvQHNvbGFuYS1tb2JpbGUvd2FsbGV0LWFkYXB0ZXItbW9iaWxlL2xpYi9lc20vaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQmFzZVNpZ25Jbk1lc3NhZ2VTaWduZXJXYWxsZXRBZGFwdGVyLCBXYWxsZXRSZWFkeVN0YXRlLCBXYWxsZXRQdWJsaWNLZXlFcnJvciwgV2FsbGV0Tm90UmVhZHlFcnJvciwgV2FsbGV0Q29ubmVjdGlvbkVycm9yLCBXYWxsZXREaXNjb25uZWN0ZWRFcnJvciwgV2FsbGV0Tm90Q29ubmVjdGVkRXJyb3IsIFdhbGxldFNpZ25UcmFuc2FjdGlvbkVycm9yLCBXYWxsZXRTZW5kVHJhbnNhY3Rpb25FcnJvciwgV2FsbGV0U2lnbk1lc3NhZ2VFcnJvciwgaXNWZXJzaW9uZWRUcmFuc2FjdGlvbiBhcyBpc1ZlcnNpb25lZFRyYW5zYWN0aW9uJDEgfSBmcm9tICdAc29sYW5hL3dhbGxldC1hZGFwdGVyLWJhc2UnO1xuaW1wb3J0IHsgUHVibGljS2V5IH0gZnJvbSAnQHNvbGFuYS93ZWIzLmpzJztcbmltcG9ydCB7IHRyYW5zYWN0LCB0cmFuc2FjdFJlbW90ZSB9IGZyb20gJ0Bzb2xhbmEtbW9iaWxlL21vYmlsZS13YWxsZXQtYWRhcHRlci1wcm90b2NvbC13ZWIzanMnO1xuaW1wb3J0IFFSQ29kZSBmcm9tICdxcmNvZGUnO1xuaW1wb3J0IHsgdG9VaW50OEFycmF5IGFzIHRvVWludDhBcnJheSQxIH0gZnJvbSAnanMtYmFzZTY0JztcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcblxyXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXHJcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXHJcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcblxyXG5mdW5jdGlvbiBfX2F3YWl0ZXIodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cclxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgIH0pO1xyXG59XG5cbmZ1bmN0aW9uIHRvVWludDhBcnJheShiYXNlNjRFbmNvZGVkQnl0ZUFycmF5KSB7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHdpbmRvd1xuICAgICAgICAuYXRvYihiYXNlNjRFbmNvZGVkQnl0ZUFycmF5KVxuICAgICAgICAuc3BsaXQoJycpXG4gICAgICAgIC5tYXAoKGMpID0+IGMuY2hhckNvZGVBdCgwKSkpO1xufVxuXG5mdW5jdGlvbiBnZXRJc1N1cHBvcnRlZCQxKCkge1xuICAgIHJldHVybiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgd2luZG93LmlzU2VjdXJlQ29udGV4dCAmJlxuICAgICAgICB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgIC9hbmRyb2lkL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSk7XG59XG5cbmNvbnN0IFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXROYW1lID0gJ01vYmlsZSBXYWxsZXQgQWRhcHRlcic7XG5jb25zdCBTSUdOQVRVUkVfTEVOR1RIX0lOX0JZVEVTJDEgPSA2NDtcbmZ1bmN0aW9uIGdldFB1YmxpY0tleUZyb21BZGRyZXNzJDEoYWRkcmVzcykge1xuICAgIGNvbnN0IHB1YmxpY0tleUJ5dGVBcnJheSA9IHRvVWludDhBcnJheShhZGRyZXNzKTtcbiAgICByZXR1cm4gbmV3IFB1YmxpY0tleShwdWJsaWNLZXlCeXRlQXJyYXkpO1xufVxuZnVuY3Rpb24gaXNWZXJzaW9uZWRUcmFuc2FjdGlvbih0cmFuc2FjdGlvbikge1xuICAgIHJldHVybiAndmVyc2lvbicgaW4gdHJhbnNhY3Rpb247XG59XG5mdW5jdGlvbiBjbHVzdGVyVG9DaGFpbklkKGNsdXN0ZXIpIHtcbiAgICBzd2l0Y2ggKGNsdXN0ZXIpIHtcbiAgICAgICAgY2FzZSAnbWFpbm5ldC1iZXRhJzpcbiAgICAgICAgICAgIHJldHVybiAnc29sYW5hOm1haW5uZXQnO1xuICAgICAgICBjYXNlICd0ZXN0bmV0JzpcbiAgICAgICAgICAgIHJldHVybiAnc29sYW5hOnRlc3RuZXQnO1xuICAgICAgICBjYXNlICdkZXZuZXQnOlxuICAgICAgICAgICAgcmV0dXJuICdzb2xhbmE6ZGV2bmV0JztcbiAgICB9XG59XG5jbGFzcyBTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyIGV4dGVuZHMgQmFzZVNpZ25Jbk1lc3NhZ2VTaWduZXJXYWxsZXRBZGFwdGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnN1cHBvcnRlZFRyYW5zYWN0aW9uVmVyc2lvbnMgPSBuZXcgU2V0KFxuICAgICAgICAvLyBGSVhNRSgjMjQ0KTogV2UgY2FuJ3QgYWN0dWFsbHkga25vdyB3aGF0IHZlcnNpb25zIGFyZSBzdXBwb3J0ZWQgdW50aWwgd2Uga25vdyB3aGljaCB3YWxsZXQgd2UncmUgdGFsa2luZyB0by5cbiAgICAgICAgWydsZWdhY3knLCAwXSk7XG4gICAgICAgIHRoaXMubmFtZSA9IFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXROYW1lO1xuICAgICAgICB0aGlzLnVybCA9ICdodHRwczovL3NvbGFuYW1vYmlsZS5jb20vd2FsbGV0cyc7XG4gICAgICAgIHRoaXMuaWNvbiA9ICdkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUJtYVd4c1BTSnViMjVsSWlCb1pXbG5hSFE5SWpJNElpQjNhV1IwYUQwaU1qZ2lJSFpwWlhkQ2IzZzlJaTB6SURBZ01qZ2dNamdpSUhodGJHNXpQU0pvZEhSd09pOHZkM2QzTG5jekxtOXlaeTh5TURBd0wzTjJaeUkrUEdjZ1ptbHNiRDBpSTBSRFFqaEdSaUkrUEhCaGRHZ2daRDBpVFRFM0xqUWdNVGN1TkVneE5YWXlMalJvTWk0MGRpMHlMalJhYlRFdU1pMDVMalpvTFRJdU5IWXlMalJvTWk0MFZqY3VPRm9pTHo0OGNHRjBhQ0JrUFNKTk1qRXVOaUF6VmpCb0xUSXVOSFl6YUMwekxqWldNR2d0TWk0MGRqTm9MVEl1TkhZMkxqWklOQzQxWVRJdU1TQXlMakVnTUNBeElERWdNQzAwTGpKb01pNDNWak5JTkM0MVFUUXVOU0EwTGpVZ01DQXdJREFnTUNBM0xqVldNalJvTWpFdU5uWXROaTQyYUMweUxqUjJOQzR5U0RJdU5GWXhNUzQxWXk0MUxqTWdNUzR5TGpRZ01TNDRMalZvTnk0MVFUWXVOaUEyTGpZZ01DQXdJREFnTWpRZ09WWXphQzB5TGpSYWJUQWdOUzQzWVRRdU1pQTBMaklnTUNBeElERXRPQzQwSURCV05TNDBhRGd1TkhZekxqTmFJaTgrUEM5blBqd3ZjM1puUGc9PSc7XG4gICAgICAgIHRoaXMuX2Nvbm5lY3RpbmcgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEV2ZXJ5IHRpbWUgdGhlIGNvbm5lY3Rpb24gaXMgcmVjeWNsZWQgaW4gc29tZSB3YXkgKGVnLiBgZGlzY29ubmVjdCgpYCBpcyBjYWxsZWQpXG4gICAgICAgICAqIGluY3JlbWVudCB0aGlzIGFuZCB1c2UgaXQgdG8gbWFrZSBzdXJlIHRoYXQgYHRyYW5zYWN0YCBjYWxscyBmcm9tIHRoZSBwcmV2aW91c1xuICAgICAgICAgKiAnZ2VuZXJhdGlvbicgZG9uJ3QgY29udGludWUgdG8gZG8gd29yayBhbmQgdGhyb3cgZXhjZXB0aW9ucy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2Nvbm5lY3Rpb25HZW5lcmF0aW9uID0gMDtcbiAgICAgICAgdGhpcy5fcmVhZHlTdGF0ZSA9IGdldElzU3VwcG9ydGVkJDEoKSA/IFdhbGxldFJlYWR5U3RhdGUuTG9hZGFibGUgOiBXYWxsZXRSZWFkeVN0YXRlLlVuc3VwcG9ydGVkO1xuICAgICAgICB0aGlzLl9hdXRob3JpemF0aW9uUmVzdWx0Q2FjaGUgPSBjb25maWcuYXV0aG9yaXphdGlvblJlc3VsdENhY2hlO1xuICAgICAgICB0aGlzLl9hZGRyZXNzU2VsZWN0b3IgPSBjb25maWcuYWRkcmVzc1NlbGVjdG9yO1xuICAgICAgICB0aGlzLl9hcHBJZGVudGl0eSA9IGNvbmZpZy5hcHBJZGVudGl0eTtcbiAgICAgICAgdGhpcy5fY2hhaW4gPSAoX2EgPSBjb25maWcuY2hhaW4pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGNsdXN0ZXJUb0NoYWluSWQoY29uZmlnLmNsdXN0ZXIpO1xuICAgICAgICB0aGlzLl9ob3N0QXV0aG9yaXR5ID0gY29uZmlnLnJlbW90ZUhvc3RBdXRob3JpdHk7XG4gICAgICAgIHRoaXMuX29uV2FsbGV0Tm90Rm91bmQgPSBjb25maWcub25XYWxsZXROb3RGb3VuZDtcbiAgICAgICAgaWYgKHRoaXMuX3JlYWR5U3RhdGUgIT09IFdhbGxldFJlYWR5U3RhdGUuVW5zdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2F1dGhvcml6YXRpb25SZXN1bHRDYWNoZS5nZXQoKS50aGVuKChhdXRob3JpemF0aW9uUmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGF1dGhvcml6YXRpb25SZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSGF2aW5nIGEgcHJpb3IgYXV0aG9yaXphdGlvbiByZXN1bHQgaXMsIHJpZ2h0IG5vdywgdGhlIGJlc3RcbiAgICAgICAgICAgICAgICAgICAgLy8gaW5kaWNhdGlvbiB0aGF0IGEgbW9iaWxlIHdhbGxldCBpcyBpbnN0YWxsZWQuIFRoZXJlIGlzIG5vIEFQSVxuICAgICAgICAgICAgICAgICAgICAvLyB3ZSBjYW4gdXNlIHRvIHRlc3QgZm9yIHdoZXRoZXIgdGhlIGFzc29jaWF0aW9uIFVSSSBpcyBzdXBwb3J0ZWQuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVjbGFyZVdhbGxldEFzSW5zdGFsbGVkKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IHB1YmxpY0tleSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3B1YmxpY0tleSA9PSBudWxsICYmIHRoaXMuX3NlbGVjdGVkQWRkcmVzcyAhPSBudWxsKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3B1YmxpY0tleSA9IGdldFB1YmxpY0tleUZyb21BZGRyZXNzJDEodGhpcy5fc2VsZWN0ZWRBZGRyZXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFdhbGxldFB1YmxpY0tleUVycm9yKChlIGluc3RhbmNlb2YgRXJyb3IgJiYgKGUgPT09IG51bGwgfHwgZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZS5tZXNzYWdlKSkgfHwgJ1Vua25vd24gZXJyb3InLCBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fcHVibGljS2V5ID8gdGhpcy5fcHVibGljS2V5IDogbnVsbDtcbiAgICB9XG4gICAgZ2V0IGNvbm5lY3RlZCgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fYXV0aG9yaXphdGlvblJlc3VsdDtcbiAgICB9XG4gICAgZ2V0IGNvbm5lY3RpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb25uZWN0aW5nO1xuICAgIH1cbiAgICBnZXQgcmVhZHlTdGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlYWR5U3RhdGU7XG4gICAgfVxuICAgIGRlY2xhcmVXYWxsZXRBc0luc3RhbGxlZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3JlYWR5U3RhdGUgIT09IFdhbGxldFJlYWR5U3RhdGUuSW5zdGFsbGVkKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3JlYWR5U3RhdGVDaGFuZ2UnLCAodGhpcy5fcmVhZHlTdGF0ZSA9IFdhbGxldFJlYWR5U3RhdGUuSW5zdGFsbGVkKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcnVuV2l0aEd1YXJkKGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCBjYWxsYmFjaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZSk7XG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKiBAZGVwcmVjYXRlZCBVc2UgYGF1dG9Db25uZWN0KClgIGluc3RlYWQuICovXG4gICAgYXV0b0Nvbm5lY3RfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRCgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCB0aGlzLmF1dG9Db25uZWN0KCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhdXRvQ29ubmVjdCgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbm5lY3RpbmcgfHwgdGhpcy5jb25uZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5ydW5XaXRoR3VhcmQoKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9yZWFkeVN0YXRlICE9PSBXYWxsZXRSZWFkeVN0YXRlLkluc3RhbGxlZCAmJiB0aGlzLl9yZWFkeVN0YXRlICE9PSBXYWxsZXRSZWFkeVN0YXRlLkxvYWRhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBXYWxsZXROb3RSZWFkeUVycm9yKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX2Nvbm5lY3RpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNhY2hlZEF1dGhvcml6YXRpb25SZXN1bHQgPSB5aWVsZCB0aGlzLl9hdXRob3JpemF0aW9uUmVzdWx0Q2FjaGUuZ2V0KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjYWNoZWRBdXRob3JpemF0aW9uUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBFdmFsdWF0ZSB3aGV0aGVyIHRoZXJlJ3MgYW55IHRocmVhdCB0byBub3QgYGF3YWl0aW5nYCB0aGlzIGV4cHJlc3Npb25cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlQXV0aG9yaXphdGlvblJlc3VsdChjYWNoZWRBdXRob3JpemF0aW9uUmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgV2FsbGV0Q29ubmVjdGlvbkVycm9yKChlIGluc3RhbmNlb2YgRXJyb3IgJiYgZS5tZXNzYWdlKSB8fCAnVW5rbm93biBlcnJvcicsIGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29ubmVjdGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNvbm5lY3QoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25uZWN0aW5nIHx8IHRoaXMuY29ubmVjdGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHRoaXMucnVuV2l0aEd1YXJkKCgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fcmVhZHlTdGF0ZSAhPT0gV2FsbGV0UmVhZHlTdGF0ZS5JbnN0YWxsZWQgJiYgdGhpcy5fcmVhZHlTdGF0ZSAhPT0gV2FsbGV0UmVhZHlTdGF0ZS5Mb2FkYWJsZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgV2FsbGV0Tm90UmVhZHlFcnJvcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9jb25uZWN0aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLnBlcmZvcm1BdXRob3JpemF0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBXYWxsZXRDb25uZWN0aW9uRXJyb3IoKGUgaW5zdGFuY2VvZiBFcnJvciAmJiBlLm1lc3NhZ2UpIHx8ICdVbmtub3duIGVycm9yJywgZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb25uZWN0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcGVyZm9ybUF1dGhvcml6YXRpb24oc2lnbkluUGF5bG9hZCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjYWNoZWRBdXRob3JpemF0aW9uUmVzdWx0ID0geWllbGQgdGhpcy5fYXV0aG9yaXphdGlvblJlc3VsdENhY2hlLmdldCgpO1xuICAgICAgICAgICAgICAgIGlmIChjYWNoZWRBdXRob3JpemF0aW9uUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IEV2YWx1YXRlIHdoZXRoZXIgdGhlcmUncyBhbnkgdGhyZWF0IHRvIG5vdCBgYXdhaXRpbmdgIHRoaXMgZXhwcmVzc2lvblxuICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUF1dGhvcml6YXRpb25SZXN1bHQoY2FjaGVkQXV0aG9yaXphdGlvblJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZWRBdXRob3JpemF0aW9uUmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy50cmFuc2FjdCgod2FsbGV0KSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGF1dGhvcml6YXRpb25SZXN1bHQgPSB5aWVsZCB3YWxsZXQuYXV0aG9yaXplKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYWluOiB0aGlzLl9jaGFpbixcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkZW50aXR5OiB0aGlzLl9hcHBJZGVudGl0eSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25faW5fcGF5bG9hZDogc2lnbkluUGF5bG9hZCxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IEV2YWx1YXRlIHdoZXRoZXIgdGhlcmUncyBhbnkgdGhyZWF0IHRvIG5vdCBgYXdhaXRpbmdgIHRoaXMgZXhwcmVzc2lvblxuICAgICAgICAgICAgICAgICAgICBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9hdXRob3JpemF0aW9uUmVzdWx0Q2FjaGUuc2V0KGF1dGhvcml6YXRpb25SZXN1bHQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVBdXRob3JpemF0aW9uUmVzdWx0KGF1dGhvcml6YXRpb25SZXN1bHQpLFxuICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF1dGhvcml6YXRpb25SZXN1bHQ7XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgV2FsbGV0Q29ubmVjdGlvbkVycm9yKChlIGluc3RhbmNlb2YgRXJyb3IgJiYgZS5tZXNzYWdlKSB8fCAnVW5rbm93biBlcnJvcicsIGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaGFuZGxlQXV0aG9yaXphdGlvblJlc3VsdChhdXRob3JpemF0aW9uUmVzdWx0KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGRpZFB1YmxpY0tleXNDaGFuZ2UgPSBcbiAgICAgICAgICAgIC8vIENhc2UgMTogV2Ugc3RhcnRlZCBmcm9tIGhhdmluZyBubyBhdXRob3JpemF0aW9uLlxuICAgICAgICAgICAgdGhpcy5fYXV0aG9yaXphdGlvblJlc3VsdCA9PSBudWxsIHx8XG4gICAgICAgICAgICAgICAgLy8gQ2FzZSAyOiBUaGUgbnVtYmVyIG9mIGF1dGhvcml6ZWQgYWNjb3VudHMgY2hhbmdlZC5cbiAgICAgICAgICAgICAgICAoKF9hID0gdGhpcy5fYXV0aG9yaXphdGlvblJlc3VsdCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFjY291bnRzLmxlbmd0aCkgIT09IGF1dGhvcml6YXRpb25SZXN1bHQuYWNjb3VudHMubGVuZ3RoIHx8XG4gICAgICAgICAgICAgICAgLy8gQ2FzZSAzOiBUaGUgbmV3IGxpc3Qgb2YgYWRkcmVzc2VzIGlzbid0IGV4YWN0bHkgdGhlIHNhbWUgYXMgdGhlIG9sZCBsaXN0LCBpbiB0aGUgc2FtZSBvcmRlci5cbiAgICAgICAgICAgICAgICB0aGlzLl9hdXRob3JpemF0aW9uUmVzdWx0LmFjY291bnRzLnNvbWUoKGFjY291bnQsIGlpKSA9PiBhY2NvdW50LmFkZHJlc3MgIT09IGF1dGhvcml6YXRpb25SZXN1bHQuYWNjb3VudHNbaWldLmFkZHJlc3MpO1xuICAgICAgICAgICAgdGhpcy5fYXV0aG9yaXphdGlvblJlc3VsdCA9IGF1dGhvcml6YXRpb25SZXN1bHQ7XG4gICAgICAgICAgICB0aGlzLmRlY2xhcmVXYWxsZXRBc0luc3RhbGxlZCgpO1xuICAgICAgICAgICAgaWYgKGRpZFB1YmxpY0tleXNDaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0U2VsZWN0ZWRBZGRyZXNzID0geWllbGQgdGhpcy5fYWRkcmVzc1NlbGVjdG9yLnNlbGVjdChhdXRob3JpemF0aW9uUmVzdWx0LmFjY291bnRzLm1hcCgoeyBhZGRyZXNzIH0pID0+IGFkZHJlc3MpKTtcbiAgICAgICAgICAgICAgICBpZiAobmV4dFNlbGVjdGVkQWRkcmVzcyAhPT0gdGhpcy5fc2VsZWN0ZWRBZGRyZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3NlbGVjdGVkQWRkcmVzcyA9IG5leHRTZWxlY3RlZEFkZHJlc3M7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9wdWJsaWNLZXk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnY29ubmVjdCcsIFxuICAgICAgICAgICAgICAgICAgICAvLyBIYXZpbmcganVzdCBzZXQgYHRoaXMuX3NlbGVjdGVkQWRkcmVzc2AsIGB0aGlzLnB1YmxpY0tleWAgaXMgZGVmaW5pdGVseSBub24tbnVsbFxuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICAgICAgICAgICAgICB0aGlzLnB1YmxpY0tleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcGVyZm9ybVJlYXV0aG9yaXphdGlvbih3YWxsZXQsIGF1dGhUb2tlbikge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBhdXRob3JpemF0aW9uUmVzdWx0ID0geWllbGQgd2FsbGV0LmF1dGhvcml6ZSh7XG4gICAgICAgICAgICAgICAgICAgIGF1dGhfdG9rZW46IGF1dGhUb2tlbixcbiAgICAgICAgICAgICAgICAgICAgaWRlbnRpdHk6IHRoaXMuX2FwcElkZW50aXR5LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IEV2YWx1YXRlIHdoZXRoZXIgdGhlcmUncyBhbnkgdGhyZWF0IHRvIG5vdCBgYXdhaXRpbmdgIHRoaXMgZXhwcmVzc2lvblxuICAgICAgICAgICAgICAgIFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYXV0aG9yaXphdGlvblJlc3VsdENhY2hlLnNldChhdXRob3JpemF0aW9uUmVzdWx0KSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVBdXRob3JpemF0aW9uUmVzdWx0KGF1dGhvcml6YXRpb25SZXN1bHQpLFxuICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgV2FsbGV0RGlzY29ubmVjdGVkRXJyb3IoKGUgaW5zdGFuY2VvZiBFcnJvciAmJiAoZSA9PT0gbnVsbCB8fCBlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlLm1lc3NhZ2UpKSB8fCAnVW5rbm93biBlcnJvcicsIGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZGlzY29ubmVjdCgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHRoaXMuX2F1dGhvcml6YXRpb25SZXN1bHRDYWNoZS5jbGVhcigpOyAvLyBUT0RPOiBFdmFsdWF0ZSB3aGV0aGVyIHRoZXJlJ3MgYW55IHRocmVhdCB0byBub3QgYGF3YWl0aW5nYCB0aGlzIGV4cHJlc3Npb25cbiAgICAgICAgICAgIHRoaXMuX2Nvbm5lY3RpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX2Nvbm5lY3Rpb25HZW5lcmF0aW9uKys7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fYXV0aG9yaXphdGlvblJlc3VsdDtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9wdWJsaWNLZXk7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fc2VsZWN0ZWRBZGRyZXNzO1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdkaXNjb25uZWN0Jyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB0cmFuc2FjdChjYWxsYmFjaykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCB3YWxsZXRVcmlCYXNlID0gKF9hID0gdGhpcy5fYXV0aG9yaXphdGlvblJlc3VsdCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLndhbGxldF91cmlfYmFzZTtcbiAgICAgICAgICAgIGNvbnN0IGNvbmZpZyA9IHdhbGxldFVyaUJhc2UgPyB7IGJhc2VVcmk6IHdhbGxldFVyaUJhc2UgfSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGNvbnN0IHJlbW90ZUNvbmZpZyA9IHRoaXMuX2hvc3RBdXRob3JpdHkgPyB7IHJlbW90ZUhvc3RBdXRob3JpdHk6IHRoaXMuX2hvc3RBdXRob3JpdHkgfSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRDb25uZWN0aW9uR2VuZXJhdGlvbiA9IHRoaXMuX2Nvbm5lY3Rpb25HZW5lcmF0aW9uO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQgdHJhbnNhY3QoY2FsbGJhY2ssIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgY29uZmlnKSwgcmVtb3RlQ29uZmlnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9jb25uZWN0aW9uR2VuZXJhdGlvbiAhPT0gY3VycmVudENvbm5lY3Rpb25HZW5lcmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIG5ldyBQcm9taXNlKCgpID0+IHsgfSk7IC8vIE5ldmVyIHJlc29sdmUuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgRXJyb3IgJiZcbiAgICAgICAgICAgICAgICAgICAgZS5uYW1lID09PSAnU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlckVycm9yJyAmJlxuICAgICAgICAgICAgICAgICAgICBlLmNvZGUgPT09ICdFUlJPUl9XQUxMRVRfTk9UX0ZPVU5EJykge1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLl9vbldhbGxldE5vdEZvdW5kKHRoaXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXNzZXJ0SXNBdXRob3JpemVkKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2F1dGhvcml6YXRpb25SZXN1bHQgfHwgIXRoaXMuX3NlbGVjdGVkQWRkcmVzcylcbiAgICAgICAgICAgIHRocm93IG5ldyBXYWxsZXROb3RDb25uZWN0ZWRFcnJvcigpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYXV0aFRva2VuOiB0aGlzLl9hdXRob3JpemF0aW9uUmVzdWx0LmF1dGhfdG9rZW4sXG4gICAgICAgICAgICBzZWxlY3RlZEFkZHJlc3M6IHRoaXMuX3NlbGVjdGVkQWRkcmVzcyxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcGVyZm9ybVNpZ25UcmFuc2FjdGlvbnModHJhbnNhY3Rpb25zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCB7IGF1dGhUb2tlbiB9ID0gdGhpcy5hc3NlcnRJc0F1dGhvcml6ZWQoKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHRoaXMudHJhbnNhY3QoKHdhbGxldCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLnBlcmZvcm1SZWF1dGhvcml6YXRpb24od2FsbGV0LCBhdXRoVG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzaWduZWRUcmFuc2FjdGlvbnMgPSB5aWVsZCB3YWxsZXQuc2lnblRyYW5zYWN0aW9ucyh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2lnbmVkVHJhbnNhY3Rpb25zO1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBXYWxsZXRTaWduVHJhbnNhY3Rpb25FcnJvcihlcnJvciA9PT0gbnVsbCB8fCBlcnJvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXJyb3IubWVzc2FnZSwgZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2VuZFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uLCBjb25uZWN0aW9uLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5ydW5XaXRoR3VhcmQoKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgYXV0aFRva2VuIH0gPSB0aGlzLmFzc2VydElzQXV0aG9yaXplZCgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1pbkNvbnRleHRTbG90ID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm1pbkNvbnRleHRTbG90O1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCB0aGlzLnRyYW5zYWN0KCh3YWxsZXQpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGdldFRhcmdldENvbW1pdG1lbnQoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHRhcmdldENvbW1pdG1lbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChjb25uZWN0aW9uLmNvbW1pdG1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnY29uZmlybWVkJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnZmluYWxpemVkJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAncHJvY2Vzc2VkJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldENvbW1pdG1lbnQgPSBjb25uZWN0aW9uLmNvbW1pdG1lbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldENvbW1pdG1lbnQgPSAnZmluYWxpemVkJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHRhcmdldFByZWZsaWdodENvbW1pdG1lbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucHJlZmxpZ2h0Q29tbWl0bWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdjb25maXJtZWQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdmaW5hbGl6ZWQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdwcm9jZXNzZWQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0UHJlZmxpZ2h0Q29tbWl0bWVudCA9IG9wdGlvbnMucHJlZmxpZ2h0Q29tbWl0bWVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFByZWZsaWdodENvbW1pdG1lbnQgPSB0YXJnZXRDb21taXRtZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRQcmVmbGlnaHRDb21taXRtZW50ID0gJ2ZpbmFsaXplZCc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHByZWZsaWdodENvbW1pdG1lbnRTY29yZSA9IHRhcmdldFByZWZsaWdodENvbW1pdG1lbnQgPT09ICdmaW5hbGl6ZWQnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gMlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHRhcmdldFByZWZsaWdodENvbW1pdG1lbnQgPT09ICdjb25maXJtZWQnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IDFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXRDb21taXRtZW50U2NvcmUgPSB0YXJnZXRDb21taXRtZW50ID09PSAnZmluYWxpemVkJyA/IDIgOiB0YXJnZXRDb21taXRtZW50ID09PSAnY29uZmlybWVkJyA/IDEgOiAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcmVmbGlnaHRDb21taXRtZW50U2NvcmUgPCB0YXJnZXRDb21taXRtZW50U2NvcmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyB0YXJnZXRQcmVmbGlnaHRDb21taXRtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdGFyZ2V0Q29tbWl0bWVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IFtjYXBhYmlsaXRpZXMsIF8xLCBfMl0gPSB5aWVsZCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2FsbGV0LmdldENhcGFiaWxpdGllcygpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGVyZm9ybVJlYXV0aG9yaXphdGlvbih3YWxsZXQsIGF1dGhUb2tlbiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNWZXJzaW9uZWRUcmFuc2FjdGlvbih0cmFuc2FjdGlvbilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBudWxsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogVW5saWtlIHZlcnNpb25lZCB0cmFuc2FjdGlvbnMsIGxlZ2FjeSBgVHJhbnNhY3Rpb25gIG9iamVjdHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBtYXkgbm90IGhhdmUgYW4gYXNzb2NpYXRlZCBgZmVlUGF5ZXJgIG9yIGByZWNlbnRCbG9ja2hhc2hgLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIFRoaXMgY29kZSBleGlzdHMgdG8gcGF0Y2ggdGhlbSB1cCBpbiBjYXNlIHRoZXkgYXJlIG1pc3NpbmcuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbi5mZWVQYXllciB8fCAodHJhbnNhY3Rpb24uZmVlUGF5ZXIgPSAoX2EgPSB0aGlzLnB1YmxpY0tleSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHJhbnNhY3Rpb24ucmVjZW50QmxvY2toYXNoID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBibG9ja2hhc2ggfSA9IHlpZWxkIGNvbm5lY3Rpb24uZ2V0TGF0ZXN0QmxvY2toYXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1pdG1lbnQ6IGdldFRhcmdldENvbW1pdG1lbnQoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uLnJlY2VudEJsb2NraGFzaCA9IGJsb2NraGFzaDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSkoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNhcGFiaWxpdGllcy5zdXBwb3J0c19zaWduX2FuZF9zZW5kX3RyYW5zYWN0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNpZ25hdHVyZXMgPSB5aWVsZCB3YWxsZXQuc2lnbkFuZFNlbmRUcmFuc2FjdGlvbnMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW5Db250ZXh0U2xvdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25zOiBbdHJhbnNhY3Rpb25dLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzaWduYXR1cmVzWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgW3NpZ25lZFRyYW5zYWN0aW9uXSA9IHlpZWxkIHdhbGxldC5zaWduVHJhbnNhY3Rpb25zKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25zOiBbdHJhbnNhY3Rpb25dLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1ZlcnNpb25lZFRyYW5zYWN0aW9uKHNpZ25lZFRyYW5zYWN0aW9uKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geWllbGQgY29ubmVjdGlvbi5zZW5kVHJhbnNhY3Rpb24oc2lnbmVkVHJhbnNhY3Rpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VyaWFsaXplZFRyYW5zYWN0aW9uID0gc2lnbmVkVHJhbnNhY3Rpb24uc2VyaWFsaXplKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCBjb25uZWN0aW9uLnNlbmRSYXdUcmFuc2FjdGlvbihzZXJpYWxpemVkVHJhbnNhY3Rpb24sIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyksIHsgcHJlZmxpZ2h0Q29tbWl0bWVudDogZ2V0VGFyZ2V0Q29tbWl0bWVudCgpIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBXYWxsZXRTZW5kVHJhbnNhY3Rpb25FcnJvcihlcnJvciA9PT0gbnVsbCB8fCBlcnJvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXJyb3IubWVzc2FnZSwgZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNpZ25UcmFuc2FjdGlvbih0cmFuc2FjdGlvbikge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHRoaXMucnVuV2l0aEd1YXJkKCgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBbc2lnbmVkVHJhbnNhY3Rpb25dID0geWllbGQgdGhpcy5wZXJmb3JtU2lnblRyYW5zYWN0aW9ucyhbdHJhbnNhY3Rpb25dKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2lnbmVkVHJhbnNhY3Rpb247XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzaWduQWxsVHJhbnNhY3Rpb25zKHRyYW5zYWN0aW9ucykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHRoaXMucnVuV2l0aEd1YXJkKCgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzaWduZWRUcmFuc2FjdGlvbnMgPSB5aWVsZCB0aGlzLnBlcmZvcm1TaWduVHJhbnNhY3Rpb25zKHRyYW5zYWN0aW9ucyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNpZ25lZFRyYW5zYWN0aW9ucztcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNpZ25NZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCB0aGlzLnJ1bldpdGhHdWFyZCgoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBhdXRoVG9rZW4sIHNlbGVjdGVkQWRkcmVzcyB9ID0gdGhpcy5hc3NlcnRJc0F1dGhvcml6ZWQoKTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy50cmFuc2FjdCgod2FsbGV0KSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLnBlcmZvcm1SZWF1dGhvcml6YXRpb24od2FsbGV0LCBhdXRoVG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgW3NpZ25lZE1lc3NhZ2VdID0geWllbGQgd2FsbGV0LnNpZ25NZXNzYWdlcyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkcmVzc2VzOiBbc2VsZWN0ZWRBZGRyZXNzXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXlsb2FkczogW21lc3NhZ2VdLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzaWduYXR1cmUgPSBzaWduZWRNZXNzYWdlLnNsaWNlKC1TSUdOQVRVUkVfTEVOR1RIX0lOX0JZVEVTJDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNpZ25hdHVyZTtcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFdhbGxldFNpZ25NZXNzYWdlRXJyb3IoZXJyb3IgPT09IG51bGwgfHwgZXJyb3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVycm9yLm1lc3NhZ2UsIGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzaWduSW4oaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCB0aGlzLnJ1bldpdGhHdWFyZCgoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fcmVhZHlTdGF0ZSAhPT0gV2FsbGV0UmVhZHlTdGF0ZS5JbnN0YWxsZWQgJiYgdGhpcy5fcmVhZHlTdGF0ZSAhPT0gV2FsbGV0UmVhZHlTdGF0ZS5Mb2FkYWJsZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgV2FsbGV0Tm90UmVhZHlFcnJvcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9jb25uZWN0aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhdXRob3JpemF0aW9uUmVzdWx0ID0geWllbGQgdGhpcy5wZXJmb3JtQXV0aG9yaXphdGlvbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGlucHV0KSwgeyBkb21haW46IChfYSA9IGlucHV0ID09PSBudWxsIHx8IGlucHV0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpbnB1dC5kb21haW4pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHdpbmRvdy5sb2NhdGlvbi5ob3N0IH0pKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFhdXRob3JpemF0aW9uUmVzdWx0LnNpZ25faW5fcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTaWduIGluIGZhaWxlZCwgbm8gc2lnbiBpbiByZXN1bHQgcmV0dXJuZWQgYnkgd2FsbGV0XCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNpZ25lZEluQWRkcmVzcyA9IGF1dGhvcml6YXRpb25SZXN1bHQuc2lnbl9pbl9yZXN1bHQuYWRkcmVzcztcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2lnbmVkSW5BY2NvdW50ID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCAoX2IgPSBhdXRob3JpemF0aW9uUmVzdWx0LmFjY291bnRzLmZpbmQoYWNjID0+IGFjYy5hZGRyZXNzID09IHNpZ25lZEluQWRkcmVzcykpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZHJlc3M6IHNpZ25lZEluQWRkcmVzc1xuICAgICAgICAgICAgICAgICAgICB9KSwgeyBwdWJsaWNLZXk6IHRvVWludDhBcnJheShzaWduZWRJbkFkZHJlc3MpIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWNjb3VudDogc2lnbmVkSW5BY2NvdW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgc2lnbmVkTWVzc2FnZTogdG9VaW50OEFycmF5KGF1dGhvcml6YXRpb25SZXN1bHQuc2lnbl9pbl9yZXN1bHQuc2lnbmVkX21lc3NhZ2UpLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2lnbmF0dXJlOiB0b1VpbnQ4QXJyYXkoYXV0aG9yaXphdGlvblJlc3VsdC5zaWduX2luX3Jlc3VsdC5zaWduYXR1cmUpXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBXYWxsZXRDb25uZWN0aW9uRXJyb3IoKGUgaW5zdGFuY2VvZiBFcnJvciAmJiBlLm1lc3NhZ2UpIHx8ICdVbmtub3duIGVycm9yJywgZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb25uZWN0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5cbmNvbnN0IEJsdWV0b290aEh0bWwgPSBgXHJcbiAgICA8ZGl2IGNsYXNzPVwibW9iaWxlLXdhbGxldC1hZGFwdGVyLWVtYmVkZGVkLW1vZGFsLWNvbnRlbnRcIj5cclxuICAgIDxidXR0b24gaWQ9XCJtb2JpbGUtd2FsbGV0LWFkYXB0ZXItZW1iZWRkZWQtbW9kYWwtY2xvc2VcIiBjbGFzcz1cIm1vYmlsZS13YWxsZXQtYWRhcHRlci1lbWJlZGRlZC1tb2RhbC1jbG9zZVwiPlxyXG4gICAgICAgIDxzdmcgd2lkdGg9XCIxNFwiIGhlaWdodD1cIjE0XCI+XHJcbiAgICAgICAgPHBhdGggZD1cIk0xNCAxMi40NjEgOC4zIDYuNzcybDUuMjM0LTUuMjMzTDEyLjAwNiAwIDYuNzcyIDUuMjM0IDEuNTQgMCAwIDEuNTM5bDUuMjM0IDUuMjMzTDAgMTIuMDA2bDEuNTM5IDEuNTI4TDYuNzcyIDguM2w1LjY5IDUuN0wxNCAxMi40NjF6XCIgLz5cclxuICAgICAgICA8L3N2Zz5cclxuICAgIDwvYnV0dG9uPlxyXG4gICAgPGgxPjxiPkp1cGl0ZXI8L2I+IHdhbnRzIHRvIGNvbm5lY3Q8L2gxPlxyXG4gICAgPHAgY2xhc3M9XCJtb2JpbGUtd2FsbGV0LWFkYXB0ZXItZW1iZWRkZWQtbW9kYWwtc3VidGl0bGVcIj5Db25uZWN0IHRvIHlvdXIgbW9iaWxlIHdhbGxldCBhcHAgdGhyb3VnaCBCbHVldG9vdGguPC9wPlxyXG4gICAgPGRpdiBjbGFzcz1cIm1vYmlsZS13YWxsZXQtYWRhcHRlci1lbWJlZGRlZC1tb2RhbC1jb25uZWN0aW9uLXN0YXR1cy1jb250YWluZXJcIj5cclxuICAgICAgICA8ZGl2IGlkPVwic3RhdHVzLW5vdC1jb25uZWN0ZWRcIiBjbGFzcz1cImNvbm5lY3Rpb24tc3RhdHVzXCI+XHJcbiAgICAgICAgPHN2ZyBjbGFzcz1cImJsdWV0b290aC1pY29uXCIgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgdmlld0JveD1cIjAgMCAyNCAyNFwiPlxyXG4gICAgICAgICAgICA8cGF0aCBmaWxsPVwiI2EwYTBhMFwiIGQ9XCJNMTQuMjQgMTIuMDFsMi4zMiAyLjMyYy4yOC0uNzIuNDQtMS41MS40NC0yLjMzIDAtLjgyLS4xNi0xLjU5LS40My0yLjMxbC0yLjMzIDIuMzJ6bTUuMjktNS4zbC0xLjI2IDEuMjZjLjYzIDEuMjEuOTggMi41Ny45OCA0LjAycy0uMzYgMi44Mi0uOTggNC4wMmwxLjIgMS4yYy45Ny0xLjU0IDEuNTQtMy4zNiAxLjU0LTUuMzEtLjAxLTEuODktLjU1LTMuNjctMS40OC01LjE5em0tMy44MiAxTDEwIDJIOXY3LjU5TDQuNDEgNSAzIDYuNDEgOC41OSAxMiAzIDE3LjU5IDQuNDEgMTkgOSAxNC40MVYyMmgxbDUuNzEtNS43MS00LjMtNC4yOSA0LjMtNC4yOXpNMTEgNS44M2wxLjg4IDEuODhMMTEgOS41OVY1Ljgzem0xLjg4IDEwLjQ2TDExIDE4LjE3di0zLjc2bDEuODggMS44OHpcIi8+XHJcbiAgICAgICAgPC9zdmc+XHJcbiAgICAgICAgPHA+Tm90IGNvbm5lY3RlZDwvcD5cclxuICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8ZGl2IGlkPVwic3RhdHVzLWNvbm5lY3RpbmdcIiBjbGFzcz1cImNvbm5lY3Rpb24tc3RhdHVzXCIgc3R5bGU9XCJkaXNwbGF5Om5vbmU7XCI+XHJcbiAgICAgICAgPGRpdiBjbGFzcz1cInNwaW5uZXJcIj48L2Rpdj5cclxuICAgICAgICA8cD5Db25uZWN0aW5nLi4uPC9wPlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDxkaXYgaWQ9XCJzdGF0dXMtY29ubmVjdGVkXCIgY2xhc3M9XCJjb25uZWN0aW9uLXN0YXR1c1wiIHN0eWxlPVwiZGlzcGxheTpub25lO1wiPlxyXG4gICAgICAgIDxzdmcgY2xhc3M9XCJjaGVja21hcmstaWNvblwiIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIj5cclxuICAgICAgICAgICAgPHBhdGggZmlsbD1cIiM0Q0FGNTBcIiBkPVwiTTkgMTYuMTdMNC44MyAxMmwtMS40MiAxLjQxTDkgMTkgMjEgN2wtMS40MS0xLjQxelwiLz5cclxuICAgICAgICA8L3N2Zz5cclxuICAgICAgICA8cD5Db25uZWN0ZWQ8L3A+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICA8L2Rpdj5cclxuICAgIDxkaXYgY2xhc3M9XCJidXR0b24tZ3JvdXBcIj5cclxuICAgICAgICA8YnV0dG9uIGlkPVwiY2FuY2VsLWJ0blwiIGNsYXNzPVwiY2FuY2VsLWJ0blwiPkNhbmNlbDwvYnV0dG9uPlxyXG4gICAgICAgIDxidXR0b24gaWQ9XCJjb25uZWN0LWJ0blwiIGNsYXNzPVwiY29ubmVjdC1idG5cIj5Db25uZWN0PC9idXR0b24+XHJcbiAgICA8L2Rpdj5cclxuICAgIDwvZGl2PlxyXG5gO1xuXG5jb25zdCBRUkNvZGVIdG1sID0gYFxyXG48ZGl2IGNsYXNzPVwibW9iaWxlLXdhbGxldC1hZGFwdGVyLWVtYmVkZGVkLW1vZGFsLWNvbnRlbnRcIj5cclxuICA8YnV0dG9uIGlkPVwibW9iaWxlLXdhbGxldC1hZGFwdGVyLWVtYmVkZGVkLW1vZGFsLWNsb3NlXCIgY2xhc3M9XCJtb2JpbGUtd2FsbGV0LWFkYXB0ZXItZW1iZWRkZWQtbW9kYWwtY2xvc2VcIj5cclxuICAgIDxzdmcgd2lkdGg9XCIxNFwiIGhlaWdodD1cIjE0XCI+XHJcbiAgICAgIDxwYXRoIGQ9XCJNMTQgMTIuNDYxIDguMyA2Ljc3Mmw1LjIzNC01LjIzM0wxMi4wMDYgMCA2Ljc3MiA1LjIzNCAxLjU0IDAgMCAxLjUzOWw1LjIzNCA1LjIzM0wwIDEyLjAwNmwxLjUzOSAxLjUyOEw2Ljc3MiA4LjNsNS42OSA1LjdMMTQgMTIuNDYxelwiIC8+XHJcbiAgICA8L3N2Zz5cclxuICA8L2J1dHRvbj5cclxuICA8aDE+U2NhbiB0byBjb25uZWN0PC9oMT5cclxuICA8cCBjbGFzcz1cIm1vYmlsZS13YWxsZXQtYWRhcHRlci1lbWJlZGRlZC1tb2RhbC1zdWJ0aXRsZVwiPlVzZSB5b3VyIHdhbGxldCBhcHAgdG8gc2NhbiB0aGUgUVIgQ29kZSBhbmQgY29ubmVjdC48L3A+XHJcbiAgPGRpdiBpZD1cIm1vYmlsZS13YWxsZXQtYWRhcHRlci1lbWJlZGRlZC1tb2RhbC1xci1jb2RlLWNvbnRhaW5lclwiIC8+XHJcbjwvZGl2PlxyXG5gO1xuXG5jb25zdCBjc3MgPSBgXHJcbi5tb2JpbGUtd2FsbGV0LWFkYXB0ZXItZW1iZWRkZWQtbW9kYWwge1xyXG4gICAgZGlzcGxheTogZmxleDsgLyogVXNlIGZsZXhib3ggdG8gY2VudGVyIGNvbnRlbnQgKi9cclxuICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XHJcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjsgLyogQ2VudGVyIGhvcml6b250YWxseSAqL1xyXG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjsgLyogQ2VudGVyIHZlcnRpY2FsbHkgKi9cclxuICAgIHBvc2l0aW9uOiBmaXhlZDsgLyogU3RheSBpbiBwbGFjZSAqL1xyXG4gICAgei1pbmRleDogMTsgLyogU2l0IG9uIHRvcCAqL1xyXG4gICAgbGVmdDogMDtcclxuICAgIHRvcDogMDtcclxuICAgIHdpZHRoOiAxMDAlOyAvKiBGdWxsIHdpZHRoICovXHJcbiAgICBoZWlnaHQ6IDEwMCU7IC8qIEZ1bGwgaGVpZ2h0ICovXHJcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDAsMCwwLDAuNCk7IC8qIEJsYWNrIHcvIG9wYWNpdHkgKi9cclxufVxyXG5cclxuLm1vYmlsZS13YWxsZXQtYWRhcHRlci1lbWJlZGRlZC1tb2RhbC1jb250ZW50IHtcclxuICAgIGJhY2tncm91bmQ6ICMxMDE0MWY7XHJcbiAgICBwYWRkaW5nOiAyMHB4O1xyXG4gICAgYm9yZGVyLXJhZGl1czogMTBweDtcclxuICAgIHdpZHRoOiA4MCU7XHJcbiAgICBtYXgtd2lkdGg6IDUwMHB4O1xyXG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xyXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xyXG4gICAgZGlzcGxheTogZmxleDtcclxuICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XHJcbiAgICBhbGlnbi1pdGVtczogY2VudGVyOyAvKiBDZW50ZXIgY2hpbGRyZW4gaG9yaXpvbnRhbGx5ICovXHJcbn1cclxuXHJcbi5tb2JpbGUtd2FsbGV0LWFkYXB0ZXItZW1iZWRkZWQtbW9kYWwtc3VidGl0bGUge1xyXG4gICAgY29sb3I6ICNEOEQ4RDg7XHJcbn1cclxuXHJcbi5tb2JpbGUtd2FsbGV0LWFkYXB0ZXItZW1iZWRkZWQtbW9kYWwtY2xvc2Uge1xyXG4gICAgZGlzcGxheTogZmxleDtcclxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XHJcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcclxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcclxuICAgIHRvcDogMThweDtcclxuICAgIHJpZ2h0OiAxOHB4O1xyXG4gICAgcGFkZGluZzogMTJweDtcclxuICAgIGN1cnNvcjogcG9pbnRlcjtcclxuICAgIGJhY2tncm91bmQ6ICMxYTFmMmU7XHJcbiAgICBib3JkZXI6IG5vbmU7XHJcbiAgICBib3JkZXItcmFkaXVzOiA1MCU7XHJcbn1cclxuXHJcbi5tb2JpbGUtd2FsbGV0LWFkYXB0ZXItZW1iZWRkZWQtbW9kYWwtY2xvc2U6Zm9jdXMtdmlzaWJsZSB7XHJcbiAgICBvdXRsaW5lLWNvbG9yOiB3aGl0ZTtcclxufVxyXG5cclxuLm1vYmlsZS13YWxsZXQtYWRhcHRlci1lbWJlZGRlZC1tb2RhbC1jbG9zZSBzdmcge1xyXG4gICAgZmlsbDogIzc3NztcclxuICAgIHRyYW5zaXRpb246IGZpbGwgMjAwbXMgZWFzZSAwcztcclxufVxyXG5cclxuLm1vYmlsZS13YWxsZXQtYWRhcHRlci1lbWJlZGRlZC1tb2RhbC1jbG9zZTpob3ZlciBzdmcge1xyXG4gICAgZmlsbDogI2ZmZjtcclxufVxyXG5cclxuLmljb24tY29udGFpbmVyIHtcclxuICAgIGRpc3BsYXk6IGZsZXg7XHJcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcclxuICAgIG1hcmdpbi1ib3R0b206IDIwcHg7XHJcbn1cclxuXHJcbi5pY29uIHtcclxuICAgIHdpZHRoOiA4MHB4O1xyXG4gICAgaGVpZ2h0OiA4MHB4O1xyXG4gICAgYm9yZGVyLXJhZGl1czogNTAlO1xyXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI2RkZDsgLyogUGxhY2Vob2xkZXIgZm9yIGljb24gYmFja2dyb3VuZCAqL1xyXG59XHJcblxyXG4vKiBNb2RhbCBUaXRsZSAqL1xyXG4ubW9iaWxlLXdhbGxldC1hZGFwdGVyLWVtYmVkZGVkLW1vZGFsLWNvbnRlbnQgaDEge1xyXG4gICAgY29sb3I6IHdoaXRlO1xyXG4gICAgZm9udC1zaXplOiAyNHB4OyAgIFxyXG59XHJcblxyXG4uYnV0dG9uLWdyb3VwIHtcclxuICAgIGRpc3BsYXk6IGZsZXg7XHJcbiAgICB3aWR0aDogMTAwJTtcclxuICAgIGdhcDogMTBweDtcclxufVxyXG5cclxuLmNvbm5lY3QtYnRuLCAuY2FuY2VsLWJ0biB7XHJcbiAgICBmbGV4OiAxO1xyXG4gICAgcGFkZGluZzogMTJweCAyMHB4O1xyXG4gICAgZm9udC1zaXplOiAxNnB4O1xyXG4gICAgY3Vyc29yOiBwb2ludGVyO1xyXG4gICAgYm9yZGVyLXJhZGl1czogMTBweDtcclxuICAgIHRyYW5zaXRpb246IGFsbCAwLjNzIGVhc2U7XHJcbn1cclxuXHJcbi5jb25uZWN0LWJ0biB7XHJcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjMDA3YmZmO1xyXG4gICAgY29sb3I6IHdoaXRlO1xyXG4gICAgYm9yZGVyOiBub25lO1xyXG59XHJcblxyXG4uY29ubmVjdC1idG46aG92ZXIge1xyXG4gICAgYmFja2dyb3VuZC1jb2xvcjogIzAwNTZiMztcclxufVxyXG5cclxuLmNhbmNlbC1idG4ge1xyXG4gICAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XHJcbiAgICBjb2xvcjogI2EwYTBhMDtcclxuICAgIGJvcmRlcjogMXB4IHNvbGlkICNhMGEwYTA7XHJcbn1cclxuXHJcbi5jYW5jZWwtYnRuOmhvdmVyIHtcclxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMTYwLCAxNjAsIDE2MCwgMC4xKTtcclxufVxyXG5cclxuLyogQlQgQ29ubmVjdGlvbiBTdGF0dXMgKi9cclxuXHJcbi5tb2JpbGUtd2FsbGV0LWFkYXB0ZXItZW1iZWRkZWQtbW9kYWwtY29ubmVjdGlvbi1zdGF0dXMtY29udGFpbmVyIHtcclxuICAgIG1hcmdpbjogMjBweCAwcHggMjBweCAwcHg7XHJcbn1cclxuXHJcbi5jb25uZWN0aW9uLXN0YXR1cyB7XHJcbiAgICBkaXNwbGF5OiBmbGV4O1xyXG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcclxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XHJcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcclxuICAgIG1hcmdpbjogMjBweCAwO1xyXG59XHJcbiAgXHJcbi5jb25uZWN0aW9uLXN0YXR1cyBwIHtcclxuICAgIG1hcmdpbi10b3A6IDEwcHg7XHJcbiAgICBjb2xvcjogI2EwYTBhMDtcclxufVxyXG4gIFxyXG4uYmx1ZXRvb3RoLWljb24sIC5jaGVja21hcmstaWNvbiB7XHJcbiAgICB3aWR0aDogNDhweDtcclxuICAgIGhlaWdodDogNDhweDtcclxufVxyXG4gIFxyXG4uc3Bpbm5lciB7XHJcbiAgICBib3JkZXI6IDRweCBzb2xpZCAjZjNmM2YzO1xyXG4gICAgYm9yZGVyLXRvcDogNHB4IHNvbGlkICMzNDk4ZGI7XHJcbiAgICBib3JkZXItcmFkaXVzOiA1MCU7XHJcbiAgICB3aWR0aDogNDBweDtcclxuICAgIGhlaWdodDogNDBweDtcclxuICAgIGFuaW1hdGlvbjogc3BpbiAxcyBsaW5lYXIgaW5maW5pdGU7XHJcbn1cclxuICBcclxuQGtleWZyYW1lcyBzcGluIHtcclxuICAgIDAlIHsgdHJhbnNmb3JtOiByb3RhdGUoMGRlZyk7IH1cclxuICAgIDEwMCUgeyB0cmFuc2Zvcm06IHJvdGF0ZSgzNjBkZWcpOyB9XHJcbn1cclxuXHJcbi8qIFFSIENvZGUgKi9cclxuXHJcbiNtb2JpbGUtd2FsbGV0LWFkYXB0ZXItZW1iZWRkZWQtbW9kYWwtcXItY29kZS1jb250YWluZXIge1xyXG4gICAgd2lkdGg6IDUwMHB4O1xyXG4gICAgaGVpZ2h0OiA1MDBweDtcclxuICAgIGFsaWduLWNvbnRlbnQ6IGNlbnRlcjtcclxufVxyXG5gO1xuXG5jbGFzcyBFbWJlZGRlZE1vZGFsIHtcbiAgICBjb25zdHJ1Y3Rvcih0aXRsZSkge1xuICAgICAgICB0aGlzLl9yb290ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fdGl0bGUgPSB0aXRsZTtcbiAgICAgICAgLy8gQmluZCBtZXRob2RzIHRvIGVuc3VyZSBgdGhpc2AgY29udGV4dCBpcyBjb3JyZWN0XG4gICAgICAgIHRoaXMuaW5pdCA9IHRoaXMuaW5pdC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmluamVjdFFSQ29kZUhUTUwgPSB0aGlzLmluamVjdFFSQ29kZUhUTUwuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5pbmplY3RCbHVldG9vdGhIVE1MID0gdGhpcy5pbmplY3RCbHVldG9vdGhIVE1MLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub3BlbiA9IHRoaXMub3Blbi5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmNsb3NlID0gdGhpcy5jbG9zZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmNvbm5lY3QgPSB0aGlzLmNvbm5lY3QuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5fcm9vdCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdtb2JpbGUtd2FsbGV0LWFkYXB0ZXItZW1iZWRkZWQtcm9vdC11aScpO1xuICAgIH1cbiAgICBpbml0KHFyQ29kZSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ0luamVjdGluZyBtb2RhbCcpO1xuICAgICAgICAgICAgdGhpcy5pbmplY3RTdHlsZXMoKTtcbiAgICAgICAgICAgIHRoaXMuaW5qZWN0UVJDb2RlSFRNTChxckNvZGUpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2V0Q29ubmVjdGlvblN0YXR1cyhzdGF0dXMpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9yb290KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBzdGF0dXNlcyA9IFsnbm90LWNvbm5lY3RlZCcsICdjb25uZWN0aW5nJywgJ2Nvbm5lY3RlZCddO1xuICAgICAgICBzdGF0dXNlcy5mb3JFYWNoKChzKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBlbCA9IHRoaXMuX3Jvb3QucXVlcnlTZWxlY3RvcihgI3N0YXR1cy0ke3N9YCk7XG4gICAgICAgICAgICBpZiAoZWwgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSBzID09PSBzdGF0dXMgPyAnZmxleCcgOiAnbm9uZSc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpbmplY3RTdHlsZXMoKSB7XG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSBzdHlsZXMgaGF2ZSBhbHJlYWR5IGJlZW4gaW5qZWN0ZWRcbiAgICAgICAgaWYgKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdtb2JpbGUtd2FsbGV0LWFkYXB0ZXItc3R5bGVzJykpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdHlsZUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICAgICAgICBzdHlsZUVsZW1lbnQuaWQgPSAnbW9iaWxlLXdhbGxldC1hZGFwdGVyLXN0eWxlcyc7XG4gICAgICAgIHN0eWxlRWxlbWVudC50ZXh0Q29udGVudCA9IGNzcztcbiAgICAgICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChzdHlsZUVsZW1lbnQpO1xuICAgIH1cbiAgICBwb3B1bGF0ZVFSQ29kZShxclVybCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcXJjb2RlQ29udGFpbmVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ21vYmlsZS13YWxsZXQtYWRhcHRlci1lbWJlZGRlZC1tb2RhbC1xci1jb2RlLWNvbnRhaW5lcicpO1xuICAgICAgICAgICAgaWYgKHFyY29kZUNvbnRhaW5lcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHFyQ29kZUVsZW1lbnQgPSB5aWVsZCBRUkNvZGUudG9DYW52YXMocXJVcmwsIHsgd2lkdGg6IDQwMCB9KTtcbiAgICAgICAgICAgICAgICBpZiAocXJjb2RlQ29udGFpbmVyLmZpcnN0RWxlbWVudENoaWxkICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHFyY29kZUNvbnRhaW5lci5yZXBsYWNlQ2hpbGQocXJDb2RlRWxlbWVudCwgcXJjb2RlQ29udGFpbmVyLmZpcnN0RWxlbWVudENoaWxkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBxcmNvZGVDb250YWluZXIuYXBwZW5kQ2hpbGQocXJDb2RlRWxlbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdRUkNvZGUgQ29udGFpbmVyIG5vdCBmb3VuZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaW5qZWN0UVJDb2RlSFRNTChxckNvZGUpIHtcbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIEhUTUwgaGFzIGFscmVhZHkgYmVlbiBpbmplY3RlZFxuICAgICAgICBpZiAoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ21vYmlsZS13YWxsZXQtYWRhcHRlci1lbWJlZGRlZC1yb290LXVpJykpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fcm9vdClcbiAgICAgICAgICAgICAgICB0aGlzLl9yb290ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ21vYmlsZS13YWxsZXQtYWRhcHRlci1lbWJlZGRlZC1yb290LXVpJyk7XG4gICAgICAgICAgICB0aGlzLnBvcHVsYXRlUVJDb2RlKHFyQ29kZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ3JlYXRlIGEgY29udGFpbmVyIGZvciB0aGUgbW9kYWxcbiAgICAgICAgdGhpcy5fcm9vdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLl9yb290LmlkID0gJ21vYmlsZS13YWxsZXQtYWRhcHRlci1lbWJlZGRlZC1yb290LXVpJztcbiAgICAgICAgdGhpcy5fcm9vdC5jbGFzc05hbWUgPSAnbW9iaWxlLXdhbGxldC1hZGFwdGVyLWVtYmVkZGVkLW1vZGFsJztcbiAgICAgICAgdGhpcy5fcm9vdC5pbm5lckhUTUwgPSBRUkNvZGVIdG1sO1xuICAgICAgICB0aGlzLl9yb290LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIC8vIEFwcGVuZCB0aGUgbW9kYWwgdG8gdGhlIGJvZHlcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLl9yb290KTtcbiAgICAgICAgLy8gUmVuZGVyIHRoZSBRUkNvZGVcbiAgICAgICAgdGhpcy5wb3B1bGF0ZVFSQ29kZShxckNvZGUpO1xuICAgICAgICB0aGlzLmF0dGFjaEV2ZW50TGlzdGVuZXJzKCk7XG4gICAgfVxuICAgIGluamVjdEJsdWV0b290aEhUTUwoKSB7XG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSBIVE1MIGhhcyBhbHJlYWR5IGJlZW4gaW5qZWN0ZWRcbiAgICAgICAgaWYgKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdtb2JpbGUtd2FsbGV0LWFkYXB0ZXItZW1iZWRkZWQtcm9vdC11aScpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcm9vdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLl9yb290LmlkID0gJ21vYmlsZS13YWxsZXQtYWRhcHRlci1lbWJlZGRlZC1yb290LXVpJztcbiAgICAgICAgdGhpcy5fcm9vdC5jbGFzc05hbWUgPSAnbW9iaWxlLXdhbGxldC1hZGFwdGVyLWVtYmVkZGVkLW1vZGFsJztcbiAgICAgICAgdGhpcy5fcm9vdC5pbm5lckhUTUwgPSBCbHVldG9vdGhIdG1sO1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMuX3Jvb3QpO1xuICAgICAgICB0aGlzLmF0dGFjaEV2ZW50TGlzdGVuZXJzKCk7XG4gICAgfVxuICAgIGF0dGFjaEV2ZW50TGlzdGVuZXJzKCkge1xuICAgICAgICBpZiAoIXRoaXMuX3Jvb3QpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IGNsb3NlQnRuID0gdGhpcy5fcm9vdC5xdWVyeVNlbGVjdG9yKCcjbW9iaWxlLXdhbGxldC1hZGFwdGVyLWVtYmVkZGVkLW1vZGFsLWNsb3NlJyk7XG4gICAgICAgIGNvbnN0IGNhbmNlbEJ0biA9IHRoaXMuX3Jvb3QucXVlcnlTZWxlY3RvcignI2NhbmNlbC1idG4nKTtcbiAgICAgICAgY29uc3QgY29ubmVjdEJ0biA9IHRoaXMuX3Jvb3QucXVlcnlTZWxlY3RvcignI2Nvbm5lY3QtYnRuJyk7XG4gICAgICAgIGNsb3NlQnRuID09PSBudWxsIHx8IGNsb3NlQnRuID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjbG9zZUJ0bi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHRoaXMuY2xvc2UoKSk7XG4gICAgICAgIGNhbmNlbEJ0biA9PT0gbnVsbCB8fCBjYW5jZWxCdG4gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNhbmNlbEJ0bi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHRoaXMuY2xvc2UoKSk7XG4gICAgICAgIGNvbm5lY3RCdG4gPT09IG51bGwgfHwgY29ubmVjdEJ0biA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29ubmVjdEJ0bi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHRoaXMuY29ubmVjdCgpKTtcbiAgICB9XG4gICAgb3BlbigpIHtcbiAgICAgICAgY29uc29sZS5kZWJ1ZygnTW9kYWwgb3BlbicpO1xuICAgICAgICBpZiAodGhpcy5fcm9vdCkge1xuICAgICAgICAgICAgdGhpcy5fcm9vdC5zdHlsZS5kaXNwbGF5ID0gJ2ZsZXgnO1xuICAgICAgICAgICAgdGhpcy5zZXRDb25uZWN0aW9uU3RhdHVzKCdub3QtY29ubmVjdGVkJyk7IC8vIFJlc2V0IHN0YXR1cyB3aGVuIG9wZW5pbmdcbiAgICAgICAgfVxuICAgIH1cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgY29uc29sZS5kZWJ1ZygnTW9kYWwgY2xvc2UnKTtcbiAgICAgICAgaWYgKHRoaXMuX3Jvb3QpIHtcbiAgICAgICAgICAgIHRoaXMuX3Jvb3Quc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICAgIHRoaXMuc2V0Q29ubmVjdGlvblN0YXR1cygnbm90LWNvbm5lY3RlZCcpOyAvLyBSZXNldCBzdGF0dXMgd2hlbiBjbG9zaW5nXG4gICAgICAgIH1cbiAgICB9XG4gICAgY29ubmVjdCgpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ0Nvbm5lY3RpbmcuLi4nKTtcbiAgICAgICAgLy8gTW9jayBjb25uZWN0aW9uXG4gICAgICAgIHRoaXMuc2V0Q29ubmVjdGlvblN0YXR1cygnY29ubmVjdGluZycpO1xuICAgICAgICAvLyBTaW11bGF0ZSBjb25uZWN0aW9uIHByb2Nlc3NcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnNldENvbm5lY3Rpb25TdGF0dXMoJ2Nvbm5lY3RlZCcpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ0Nvbm5lY3RlZCEnKTtcbiAgICAgICAgfSwgNTAwMCk7IC8vIDUgc2Vjb25kcyBkZWxheVxuICAgIH1cbn1cblxuY29uc3QgU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlclJlbW90ZVdhbGxldE5hbWUgPSAnTVdBIChSZW1vdGUpJztcbmNvbnN0IFNJR05BVFVSRV9MRU5HVEhfSU5fQllURVMgPSA2NDtcbmZ1bmN0aW9uIGdldFB1YmxpY0tleUZyb21BZGRyZXNzKGFkZHJlc3MpIHtcbiAgICBjb25zdCBwdWJsaWNLZXlCeXRlQXJyYXkgPSB0b1VpbnQ4QXJyYXkkMShhZGRyZXNzKTtcbiAgICByZXR1cm4gbmV3IFB1YmxpY0tleShwdWJsaWNLZXlCeXRlQXJyYXkpO1xufVxuLyoqXG4gKiBEZXRlcm1pbmUgdGhlIG1vYmlsZSBvcGVyYXRpbmcgc3lzdGVtLlxuICogUmV0dXJucyB0cnVlIGlmIHJ1bm5pbmcgb24gYSBtb2JpbGUgb3BlcmF0aW5nIHN5c3RlbSwgb3IgZmFsc2Ugb3RoZXJ3aXNlLlxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc01vYmlsZU9wZXJhdGluZ1N5c3RlbSgpIHtcbiAgICB2YXIgdXNlckFnZW50ID0gbmF2aWdhdG9yLnVzZXJBZ2VudDtcbiAgICAvLyBXaW5kb3dzIFBob25lIG11c3QgY29tZSBmaXJzdCBiZWNhdXNlIGl0cyBVQSBhbHNvIGNvbnRhaW5zIFwiQW5kcm9pZFwiXG4gICAgaWYgKC93aW5kb3dzIHBob25lL2kudGVzdCh1c2VyQWdlbnQpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoL2FuZHJvaWQvaS50ZXN0KHVzZXJBZ2VudCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8vIGlPUyBkZXRlY3Rpb24gZnJvbTogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvOTAzOTg4NS8xNzc3MTBcbiAgICBpZiAoL2lQYWR8aVBob25lfGlQb2QvLnRlc3QodXNlckFnZW50KSAmJiAhd2luZG93Lk1TU3RyZWFtKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBnZXRJc1N1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgIHdpbmRvdy5pc1NlY3VyZUNvbnRleHQgJiZcbiAgICAgICAgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAhaXNNb2JpbGVPcGVyYXRpbmdTeXN0ZW0oKSk7XG59XG4vKipcbiAqIFRoaXMgYnVybmVyIHdhbGxldCBhZGFwdGVyIGlzIHVuc2FmZSB0byB1c2UgYW5kIGlzIG9ubHkgaW5jbHVkZWQgdG8gcHJvdmlkZSBhbiBlYXN5IHdheSBmb3IgYXBwbGljYXRpb25zIHRvIHRlc3RcbiAqIFdhbGxldCBBZGFwdGVyIHdpdGhvdXQgdXNpbmcgYSB0aGlyZC1wYXJ0eSB3YWxsZXQuXG4gKi9cbmNsYXNzIFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJSZW1vdGUgZXh0ZW5kcyBCYXNlU2lnbkluTWVzc2FnZVNpZ25lcldhbGxldEFkYXB0ZXIge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnN1cHBvcnRlZFRyYW5zYWN0aW9uVmVyc2lvbnMgPSBuZXcgU2V0KFxuICAgICAgICAvLyBGSVhNRSgjMjQ0KTogV2UgY2FuJ3QgYWN0dWFsbHkga25vdyB3aGF0IHZlcnNpb25zIGFyZSBzdXBwb3J0ZWQgdW50aWwgd2Uga25vdyB3aGljaCB3YWxsZXQgd2UncmUgdGFsa2luZyB0by5cbiAgICAgICAgWydsZWdhY3knLCAwXSk7XG4gICAgICAgIHRoaXMubmFtZSA9IFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJSZW1vdGVXYWxsZXROYW1lO1xuICAgICAgICB0aGlzLnVybCA9ICdodHRwczovL3NvbGFuYW1vYmlsZS5jb20vd2FsbGV0cyc7XG4gICAgICAgIHRoaXMuaWNvbiA9ICdkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUJtYVd4c1BTSnViMjVsSWlCb1pXbG5hSFE5SWpJNElpQjNhV1IwYUQwaU1qZ2lJSFpwWlhkQ2IzZzlJaTB6SURBZ01qZ2dNamdpSUhodGJHNXpQU0pvZEhSd09pOHZkM2QzTG5jekxtOXlaeTh5TURBd0wzTjJaeUkrUEdjZ1ptbHNiRDBpSTBSRFFqaEdSaUkrUEhCaGRHZ2daRDBpVFRFM0xqUWdNVGN1TkVneE5YWXlMalJvTWk0MGRpMHlMalJhYlRFdU1pMDVMalpvTFRJdU5IWXlMalJvTWk0MFZqY3VPRm9pTHo0OGNHRjBhQ0JrUFNKTk1qRXVOaUF6VmpCb0xUSXVOSFl6YUMwekxqWldNR2d0TWk0MGRqTm9MVEl1TkhZMkxqWklOQzQxWVRJdU1TQXlMakVnTUNBeElERWdNQzAwTGpKb01pNDNWak5JTkM0MVFUUXVOU0EwTGpVZ01DQXdJREFnTUNBM0xqVldNalJvTWpFdU5uWXROaTQyYUMweUxqUjJOQzR5U0RJdU5GWXhNUzQxWXk0MUxqTWdNUzR5TGpRZ01TNDRMalZvTnk0MVFUWXVOaUEyTGpZZ01DQXdJREFnTWpRZ09WWXphQzB5TGpSYWJUQWdOUzQzWVRRdU1pQTBMaklnTUNBeElERXRPQzQwSURCV05TNDBhRGd1TkhZekxqTmFJaTgrUEM5blBqd3ZjM1puUGc9PSc7XG4gICAgICAgIHRoaXMuX2Nvbm5lY3RpbmcgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEV2ZXJ5IHRpbWUgdGhlIGNvbm5lY3Rpb24gaXMgcmVjeWNsZWQgaW4gc29tZSB3YXkgKGVnLiBgZGlzY29ubmVjdCgpYCBpcyBjYWxsZWQpXG4gICAgICAgICAqIGluY3JlbWVudCB0aGlzIGFuZCB1c2UgaXQgdG8gbWFrZSBzdXJlIHRoYXQgYHRyYW5zYWN0YCBjYWxscyBmcm9tIHRoZSBwcmV2aW91c1xuICAgICAgICAgKiAnZ2VuZXJhdGlvbicgZG9uJ3QgY29udGludWUgdG8gZG8gd29yayBhbmQgdGhyb3cgZXhjZXB0aW9ucy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2Nvbm5lY3Rpb25HZW5lcmF0aW9uID0gMDtcbiAgICAgICAgdGhpcy5fcmVhZHlTdGF0ZSA9IGdldElzU3VwcG9ydGVkKCkgPyBXYWxsZXRSZWFkeVN0YXRlLkxvYWRhYmxlIDogV2FsbGV0UmVhZHlTdGF0ZS5VbnN1cHBvcnRlZDtcbiAgICAgICAgdGhpcy5fYXV0aG9yaXphdGlvblJlc3VsdENhY2hlID0gY29uZmlnLmF1dGhvcml6YXRpb25SZXN1bHRDYWNoZTtcbiAgICAgICAgdGhpcy5fYWRkcmVzc1NlbGVjdG9yID0gY29uZmlnLmFkZHJlc3NTZWxlY3RvcjtcbiAgICAgICAgdGhpcy5fYXBwSWRlbnRpdHkgPSBjb25maWcuYXBwSWRlbnRpdHk7XG4gICAgICAgIHRoaXMuX2NoYWluID0gY29uZmlnLmNoYWluO1xuICAgICAgICB0aGlzLl9ob3N0QXV0aG9yaXR5ID0gY29uZmlnLnJlbW90ZUhvc3RBdXRob3JpdHk7XG4gICAgICAgIHRoaXMuX29uV2FsbGV0Tm90Rm91bmQgPSBjb25maWcub25XYWxsZXROb3RGb3VuZDtcbiAgICAgICAgaWYgKHRoaXMuX3JlYWR5U3RhdGUgIT09IFdhbGxldFJlYWR5U3RhdGUuVW5zdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2F1dGhvcml6YXRpb25SZXN1bHRDYWNoZS5nZXQoKS50aGVuKChhdXRob3JpemF0aW9uUmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGF1dGhvcml6YXRpb25SZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSGF2aW5nIGEgcHJpb3IgYXV0aG9yaXphdGlvbiByZXN1bHQgaXMsIHJpZ2h0IG5vdywgdGhlIGJlc3RcbiAgICAgICAgICAgICAgICAgICAgLy8gaW5kaWNhdGlvbiB0aGF0IGEgbW9iaWxlIHdhbGxldCBpcyBpbnN0YWxsZWQuIFRoZXJlIGlzIG5vIEFQSVxuICAgICAgICAgICAgICAgICAgICAvLyB3ZSBjYW4gdXNlIHRvIHRlc3QgZm9yIHdoZXRoZXIgdGhlIGFzc29jaWF0aW9uIFVSSSBpcyBzdXBwb3J0ZWQuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVjbGFyZVdhbGxldEFzSW5zdGFsbGVkKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IHB1YmxpY0tleSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3B1YmxpY0tleSA9PSBudWxsICYmIHRoaXMuX3NlbGVjdGVkQWRkcmVzcyAhPSBudWxsKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3B1YmxpY0tleSA9IGdldFB1YmxpY0tleUZyb21BZGRyZXNzKHRoaXMuX3NlbGVjdGVkQWRkcmVzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBXYWxsZXRQdWJsaWNLZXlFcnJvcigoZSBpbnN0YW5jZW9mIEVycm9yICYmIChlID09PSBudWxsIHx8IGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGUubWVzc2FnZSkpIHx8ICdVbmtub3duIGVycm9yJywgZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3B1YmxpY0tleSA/IHRoaXMuX3B1YmxpY0tleSA6IG51bGw7XG4gICAgfVxuICAgIGdldCBjb25uZWN0ZWQoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX2F1dGhvcml6YXRpb25SZXN1bHQ7XG4gICAgfVxuICAgIGdldCBjb25uZWN0aW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29ubmVjdGluZztcbiAgICB9XG4gICAgZ2V0IHJlYWR5U3RhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWFkeVN0YXRlO1xuICAgIH1cbiAgICBkZWNsYXJlV2FsbGV0QXNJbnN0YWxsZWQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9yZWFkeVN0YXRlICE9PSBXYWxsZXRSZWFkeVN0YXRlLkluc3RhbGxlZCkge1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdyZWFkeVN0YXRlQ2hhbmdlJywgKHRoaXMuX3JlYWR5U3RhdGUgPSBXYWxsZXRSZWFkeVN0YXRlLkluc3RhbGxlZCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJ1bldpdGhHdWFyZChjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIGUpO1xuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhdXRvQ29ubmVjdCgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbm5lY3RpbmcgfHwgdGhpcy5jb25uZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5ydW5XaXRoR3VhcmQoKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9yZWFkeVN0YXRlICE9PSBXYWxsZXRSZWFkeVN0YXRlLkluc3RhbGxlZCAmJiB0aGlzLl9yZWFkeVN0YXRlICE9PSBXYWxsZXRSZWFkeVN0YXRlLkxvYWRhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBXYWxsZXROb3RSZWFkeUVycm9yKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX2Nvbm5lY3RpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNhY2hlZEF1dGhvcml6YXRpb25SZXN1bHQgPSB5aWVsZCB0aGlzLl9hdXRob3JpemF0aW9uUmVzdWx0Q2FjaGUuZ2V0KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjYWNoZWRBdXRob3JpemF0aW9uUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBFdmFsdWF0ZSB3aGV0aGVyIHRoZXJlJ3MgYW55IHRocmVhdCB0byBub3QgYGF3YWl0aW5nYCB0aGlzIGV4cHJlc3Npb25cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlQXV0aG9yaXphdGlvblJlc3VsdChjYWNoZWRBdXRob3JpemF0aW9uUmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgV2FsbGV0Q29ubmVjdGlvbkVycm9yKChlIGluc3RhbmNlb2YgRXJyb3IgJiYgZS5tZXNzYWdlKSB8fCAnVW5rbm93biBlcnJvcicsIGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29ubmVjdGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNvbm5lY3QoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25uZWN0aW5nIHx8IHRoaXMuY29ubmVjdGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHRoaXMucnVuV2l0aEd1YXJkKCgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fcmVhZHlTdGF0ZSAhPT0gV2FsbGV0UmVhZHlTdGF0ZS5JbnN0YWxsZWQgJiYgdGhpcy5fcmVhZHlTdGF0ZSAhPT0gV2FsbGV0UmVhZHlTdGF0ZS5Mb2FkYWJsZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgV2FsbGV0Tm90UmVhZHlFcnJvcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9jb25uZWN0aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLnBlcmZvcm1BdXRob3JpemF0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBXYWxsZXRDb25uZWN0aW9uRXJyb3IoKGUgaW5zdGFuY2VvZiBFcnJvciAmJiBlLm1lc3NhZ2UpIHx8ICdVbmtub3duIGVycm9yJywgZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb25uZWN0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcGVyZm9ybUF1dGhvcml6YXRpb24oc2lnbkluUGF5bG9hZCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjYWNoZWRBdXRob3JpemF0aW9uUmVzdWx0ID0geWllbGQgdGhpcy5fYXV0aG9yaXphdGlvblJlc3VsdENhY2hlLmdldCgpO1xuICAgICAgICAgICAgICAgIGlmIChjYWNoZWRBdXRob3JpemF0aW9uUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IEV2YWx1YXRlIHdoZXRoZXIgdGhlcmUncyBhbnkgdGhyZWF0IHRvIG5vdCBgYXdhaXRpbmdgIHRoaXMgZXhwcmVzc2lvblxuICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUF1dGhvcml6YXRpb25SZXN1bHQoY2FjaGVkQXV0aG9yaXphdGlvblJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZWRBdXRob3JpemF0aW9uUmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fd2FsbGV0KVxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fd2FsbGV0O1xuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCB0aGlzLnRyYW5zYWN0KCh3YWxsZXQpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fd2FsbGV0ID0gd2FsbGV0O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhdXRob3JpemF0aW9uUmVzdWx0ID0geWllbGQgd2FsbGV0LmF1dGhvcml6ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFpbjogdGhpcy5fY2hhaW4sXG4gICAgICAgICAgICAgICAgICAgICAgICBpZGVudGl0eTogdGhpcy5fYXBwSWRlbnRpdHksXG4gICAgICAgICAgICAgICAgICAgICAgICBzaWduX2luX3BheWxvYWQ6IHNpZ25JblBheWxvYWQsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBFdmFsdWF0ZSB3aGV0aGVyIHRoZXJlJ3MgYW55IHRocmVhdCB0byBub3QgYGF3YWl0aW5nYCB0aGlzIGV4cHJlc3Npb25cbiAgICAgICAgICAgICAgICAgICAgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYXV0aG9yaXphdGlvblJlc3VsdENhY2hlLnNldChhdXRob3JpemF0aW9uUmVzdWx0KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlQXV0aG9yaXphdGlvblJlc3VsdChhdXRob3JpemF0aW9uUmVzdWx0KSxcbiAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhdXRob3JpemF0aW9uUmVzdWx0O1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFdhbGxldENvbm5lY3Rpb25FcnJvcigoZSBpbnN0YW5jZW9mIEVycm9yICYmIGUubWVzc2FnZSkgfHwgJ1Vua25vd24gZXJyb3InLCBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGhhbmRsZUF1dGhvcml6YXRpb25SZXN1bHQoYXV0aG9yaXphdGlvblJlc3VsdCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBkaWRQdWJsaWNLZXlzQ2hhbmdlID0gXG4gICAgICAgICAgICAvLyBDYXNlIDE6IFdlIHN0YXJ0ZWQgZnJvbSBoYXZpbmcgbm8gYXV0aG9yaXphdGlvbi5cbiAgICAgICAgICAgIHRoaXMuX2F1dGhvcml6YXRpb25SZXN1bHQgPT0gbnVsbCB8fFxuICAgICAgICAgICAgICAgIC8vIENhc2UgMjogVGhlIG51bWJlciBvZiBhdXRob3JpemVkIGFjY291bnRzIGNoYW5nZWQuXG4gICAgICAgICAgICAgICAgKChfYSA9IHRoaXMuX2F1dGhvcml6YXRpb25SZXN1bHQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hY2NvdW50cy5sZW5ndGgpICE9PSBhdXRob3JpemF0aW9uUmVzdWx0LmFjY291bnRzLmxlbmd0aCB8fFxuICAgICAgICAgICAgICAgIC8vIENhc2UgMzogVGhlIG5ldyBsaXN0IG9mIGFkZHJlc3NlcyBpc24ndCBleGFjdGx5IHRoZSBzYW1lIGFzIHRoZSBvbGQgbGlzdCwgaW4gdGhlIHNhbWUgb3JkZXIuXG4gICAgICAgICAgICAgICAgdGhpcy5fYXV0aG9yaXphdGlvblJlc3VsdC5hY2NvdW50cy5zb21lKChhY2NvdW50LCBpaSkgPT4gYWNjb3VudC5hZGRyZXNzICE9PSBhdXRob3JpemF0aW9uUmVzdWx0LmFjY291bnRzW2lpXS5hZGRyZXNzKTtcbiAgICAgICAgICAgIHRoaXMuX2F1dGhvcml6YXRpb25SZXN1bHQgPSBhdXRob3JpemF0aW9uUmVzdWx0O1xuICAgICAgICAgICAgdGhpcy5kZWNsYXJlV2FsbGV0QXNJbnN0YWxsZWQoKTtcbiAgICAgICAgICAgIGlmIChkaWRQdWJsaWNLZXlzQ2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dFNlbGVjdGVkQWRkcmVzcyA9IHlpZWxkIHRoaXMuX2FkZHJlc3NTZWxlY3Rvci5zZWxlY3QoYXV0aG9yaXphdGlvblJlc3VsdC5hY2NvdW50cy5tYXAoKHsgYWRkcmVzcyB9KSA9PiBhZGRyZXNzKSk7XG4gICAgICAgICAgICAgICAgaWYgKG5leHRTZWxlY3RlZEFkZHJlc3MgIT09IHRoaXMuX3NlbGVjdGVkQWRkcmVzcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZWxlY3RlZEFkZHJlc3MgPSBuZXh0U2VsZWN0ZWRBZGRyZXNzO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fcHVibGljS2V5O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2Nvbm5lY3QnLCBcbiAgICAgICAgICAgICAgICAgICAgLy8gSGF2aW5nIGp1c3Qgc2V0IGB0aGlzLl9zZWxlY3RlZEFkZHJlc3NgLCBgdGhpcy5wdWJsaWNLZXlgIGlzIGRlZmluaXRlbHkgbm9uLW51bGxcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wdWJsaWNLZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHBlcmZvcm1SZWF1dGhvcml6YXRpb24od2FsbGV0LCBhdXRoVG9rZW4pIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYXV0aG9yaXphdGlvblJlc3VsdCA9IHlpZWxkIHdhbGxldC5hdXRob3JpemUoe1xuICAgICAgICAgICAgICAgICAgICBhdXRoX3Rva2VuOiBhdXRoVG9rZW4sXG4gICAgICAgICAgICAgICAgICAgIGlkZW50aXR5OiB0aGlzLl9hcHBJZGVudGl0eSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBFdmFsdWF0ZSB3aGV0aGVyIHRoZXJlJ3MgYW55IHRocmVhdCB0byBub3QgYGF3YWl0aW5nYCB0aGlzIGV4cHJlc3Npb25cbiAgICAgICAgICAgICAgICBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2F1dGhvcml6YXRpb25SZXN1bHRDYWNoZS5zZXQoYXV0aG9yaXphdGlvblJlc3VsdCksXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlQXV0aG9yaXphdGlvblJlc3VsdChhdXRob3JpemF0aW9uUmVzdWx0KSxcbiAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFdhbGxldERpc2Nvbm5lY3RlZEVycm9yKChlIGluc3RhbmNlb2YgRXJyb3IgJiYgKGUgPT09IG51bGwgfHwgZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZS5tZXNzYWdlKSkgfHwgJ1Vua25vd24gZXJyb3InLCBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGRpc2Nvbm5lY3QoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IGZpZ3VyZSBvdXQgd2h5IHRoaXMgY2FsbCB0aHJvd3MgXCJUeXBlRXJyb3I6IF9hLnRlcm1pbmF0ZVNlc3Npb24gaXMgbm90IGEgZnVuY3Rpb25cIlxuICAgICAgICAgICAgLy8gIGV2ZW4gdGhvdWdoIHRoZSBzZXNzaW9uIHRlcm1pbmF0aW9uIGlzIGFjdHVhbGx5IGV4ZWN1dGVkICh3ZWJzb2NrZXQgY2xvc2VzKS4gXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIChfYSA9IHRoaXMuX3dhbGxldCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnRlcm1pbmF0ZVNlc3Npb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7IH1cbiAgICAgICAgICAgIHRoaXMuX2F1dGhvcml6YXRpb25SZXN1bHRDYWNoZS5jbGVhcigpOyAvLyBUT0RPOiBFdmFsdWF0ZSB3aGV0aGVyIHRoZXJlJ3MgYW55IHRocmVhdCB0byBub3QgYGF3YWl0aW5nYCB0aGlzIGV4cHJlc3Npb25cbiAgICAgICAgICAgIHRoaXMuX2Nvbm5lY3RpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX2Nvbm5lY3Rpb25HZW5lcmF0aW9uKys7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fYXV0aG9yaXphdGlvblJlc3VsdDtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9wdWJsaWNLZXk7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fc2VsZWN0ZWRBZGRyZXNzO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3dhbGxldDtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnZGlzY29ubmVjdCcpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgdHJhbnNhY3QoY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3Qgd2FsbGV0VXJpQmFzZSA9IChfYSA9IHRoaXMuX2F1dGhvcml6YXRpb25SZXN1bHQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS53YWxsZXRfdXJpX2Jhc2U7XG4gICAgICAgICAgICBjb25zdCBiYXNlQ29uZmlnID0gd2FsbGV0VXJpQmFzZSA/IHsgYmFzZVVyaTogd2FsbGV0VXJpQmFzZSB9IDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgY29uc3QgcmVtb3RlQ29uZmlnID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBiYXNlQ29uZmlnKSwgeyByZW1vdGVIb3N0QXV0aG9yaXR5OiB0aGlzLl9ob3N0QXV0aG9yaXR5IH0pO1xuICAgICAgICAgICAgY29uc3QgY3VycmVudENvbm5lY3Rpb25HZW5lcmF0aW9uID0gdGhpcy5fY29ubmVjdGlvbkdlbmVyYXRpb247XG4gICAgICAgICAgICBjb25zdCBtb2RhbCA9IG5ldyBFbWJlZGRlZE1vZGFsKCdNV0EgUVInKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl93YWxsZXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sodGhpcy5fd2FsbGV0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBhc3NvY2lhdGlvblVybCwgcmVzdWx0OiBwcm9taXNlIH0gPSB5aWVsZCB0cmFuc2FjdFJlbW90ZSgod2FsbGV0KSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHlpZWxkIGNhbGxiYWNrKHdhbGxldCk7XG4gICAgICAgICAgICAgICAgICAgIG1vZGFsLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfSksIHJlbW90ZUNvbmZpZyk7XG4gICAgICAgICAgICAgICAgbW9kYWwuaW5pdChhc3NvY2lhdGlvblVybC50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICBtb2RhbC5vcGVuKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHByb21pc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIG1vZGFsLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2Nvbm5lY3Rpb25HZW5lcmF0aW9uICE9PSBjdXJyZW50Q29ubmVjdGlvbkdlbmVyYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgbmV3IFByb21pc2UoKCkgPT4geyB9KTsgLy8gTmV2ZXIgcmVzb2x2ZS5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBFcnJvciAmJlxuICAgICAgICAgICAgICAgICAgICBlLm5hbWUgPT09ICdTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyRXJyb3InICYmXG4gICAgICAgICAgICAgICAgICAgIGUuY29kZSA9PT0gJ0VSUk9SX1dBTExFVF9OT1RfRk9VTkQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMuX29uV2FsbGV0Tm90Rm91bmQodGhpcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3NlcnRJc0F1dGhvcml6ZWQoKSB7XG4gICAgICAgIGlmICghdGhpcy5fYXV0aG9yaXphdGlvblJlc3VsdCB8fCAhdGhpcy5fc2VsZWN0ZWRBZGRyZXNzKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFdhbGxldE5vdENvbm5lY3RlZEVycm9yKCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhdXRoVG9rZW46IHRoaXMuX2F1dGhvcml6YXRpb25SZXN1bHQuYXV0aF90b2tlbixcbiAgICAgICAgICAgIHNlbGVjdGVkQWRkcmVzczogdGhpcy5fc2VsZWN0ZWRBZGRyZXNzLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBwZXJmb3JtU2lnblRyYW5zYWN0aW9ucyh0cmFuc2FjdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgYXV0aFRva2VuIH0gPSB0aGlzLmFzc2VydElzQXV0aG9yaXplZCgpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy50cmFuc2FjdCgod2FsbGV0KSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMucGVyZm9ybVJlYXV0aG9yaXphdGlvbih3YWxsZXQsIGF1dGhUb2tlbik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNpZ25lZFRyYW5zYWN0aW9ucyA9IHlpZWxkIHdhbGxldC5zaWduVHJhbnNhY3Rpb25zKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzaWduZWRUcmFuc2FjdGlvbnM7XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFdhbGxldFNpZ25UcmFuc2FjdGlvbkVycm9yKGVycm9yID09PSBudWxsIHx8IGVycm9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlcnJvci5tZXNzYWdlLCBlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzZW5kVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24sIGNvbm5lY3Rpb24sIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCB0aGlzLnJ1bldpdGhHdWFyZCgoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBhdXRoVG9rZW4gfSA9IHRoaXMuYXNzZXJ0SXNBdXRob3JpemVkKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgbWluQ29udGV4dFNsb3QgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMubWluQ29udGV4dFNsb3Q7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHRoaXMudHJhbnNhY3QoKHdhbGxldCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gZ2V0VGFyZ2V0Q29tbWl0bWVudCgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgdGFyZ2V0Q29tbWl0bWVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGNvbm5lY3Rpb24uY29tbWl0bWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdjb25maXJtZWQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdmaW5hbGl6ZWQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdwcm9jZXNzZWQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0Q29tbWl0bWVudCA9IGNvbm5lY3Rpb24uY29tbWl0bWVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0Q29tbWl0bWVudCA9ICdmaW5hbGl6ZWQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgdGFyZ2V0UHJlZmxpZ2h0Q29tbWl0bWVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5wcmVmbGlnaHRDb21taXRtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2NvbmZpcm1lZCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2ZpbmFsaXplZCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3Byb2Nlc3NlZCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRQcmVmbGlnaHRDb21taXRtZW50ID0gb3B0aW9ucy5wcmVmbGlnaHRDb21taXRtZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0UHJlZmxpZ2h0Q29tbWl0bWVudCA9IHRhcmdldENvbW1pdG1lbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFByZWZsaWdodENvbW1pdG1lbnQgPSAnZmluYWxpemVkJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJlZmxpZ2h0Q29tbWl0bWVudFNjb3JlID0gdGFyZ2V0UHJlZmxpZ2h0Q29tbWl0bWVudCA9PT0gJ2ZpbmFsaXplZCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyAyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdGFyZ2V0UHJlZmxpZ2h0Q29tbWl0bWVudCA9PT0gJ2NvbmZpcm1lZCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gMVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRhcmdldENvbW1pdG1lbnRTY29yZSA9IHRhcmdldENvbW1pdG1lbnQgPT09ICdmaW5hbGl6ZWQnID8gMiA6IHRhcmdldENvbW1pdG1lbnQgPT09ICdjb25maXJtZWQnID8gMSA6IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByZWZsaWdodENvbW1pdG1lbnRTY29yZSA8IHRhcmdldENvbW1pdG1lbnRTY29yZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHRhcmdldFByZWZsaWdodENvbW1pdG1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB0YXJnZXRDb21taXRtZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgW2NhcGFiaWxpdGllcywgXzEsIF8yXSA9IHlpZWxkIFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3YWxsZXQuZ2V0Q2FwYWJpbGl0aWVzKCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wZXJmb3JtUmVhdXRob3JpemF0aW9uKHdhbGxldCwgYXV0aFRva2VuKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1ZlcnNpb25lZFRyYW5zYWN0aW9uJDEodHJhbnNhY3Rpb24pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gbnVsbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIFVubGlrZSB2ZXJzaW9uZWQgdHJhbnNhY3Rpb25zLCBsZWdhY3kgYFRyYW5zYWN0aW9uYCBvYmplY3RzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogbWF5IG5vdCBoYXZlIGFuIGFzc29jaWF0ZWQgYGZlZVBheWVyYCBvciBgcmVjZW50QmxvY2toYXNoYC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBUaGlzIGNvZGUgZXhpc3RzIHRvIHBhdGNoIHRoZW0gdXAgaW4gY2FzZSB0aGV5IGFyZSBtaXNzaW5nLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb24uZmVlUGF5ZXIgfHwgKHRyYW5zYWN0aW9uLmZlZVBheWVyID0gKF9hID0gdGhpcy5wdWJsaWNLZXkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRyYW5zYWN0aW9uLnJlY2VudEJsb2NraGFzaCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgYmxvY2toYXNoIH0gPSB5aWVsZCBjb25uZWN0aW9uLmdldExhdGVzdEJsb2NraGFzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21taXRtZW50OiBnZXRUYXJnZXRDb21taXRtZW50KCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbi5yZWNlbnRCbG9ja2hhc2ggPSBibG9ja2hhc2g7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpKCksXG4gICAgICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYXBhYmlsaXRpZXMuc3VwcG9ydHNfc2lnbl9hbmRfc2VuZF90cmFuc2FjdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzaWduYXR1cmVzID0geWllbGQgd2FsbGV0LnNpZ25BbmRTZW5kVHJhbnNhY3Rpb25zKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWluQ29udGV4dFNsb3QsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uczogW3RyYW5zYWN0aW9uXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2lnbmF0dXJlc1swXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IFtzaWduZWRUcmFuc2FjdGlvbl0gPSB5aWVsZCB3YWxsZXQuc2lnblRyYW5zYWN0aW9ucyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uczogW3RyYW5zYWN0aW9uXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNWZXJzaW9uZWRUcmFuc2FjdGlvbiQxKHNpZ25lZFRyYW5zYWN0aW9uKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geWllbGQgY29ubmVjdGlvbi5zZW5kVHJhbnNhY3Rpb24oc2lnbmVkVHJhbnNhY3Rpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VyaWFsaXplZFRyYW5zYWN0aW9uID0gc2lnbmVkVHJhbnNhY3Rpb24uc2VyaWFsaXplKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCBjb25uZWN0aW9uLnNlbmRSYXdUcmFuc2FjdGlvbihzZXJpYWxpemVkVHJhbnNhY3Rpb24sIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyksIHsgcHJlZmxpZ2h0Q29tbWl0bWVudDogZ2V0VGFyZ2V0Q29tbWl0bWVudCgpIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBXYWxsZXRTZW5kVHJhbnNhY3Rpb25FcnJvcihlcnJvciA9PT0gbnVsbCB8fCBlcnJvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXJyb3IubWVzc2FnZSwgZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNpZ25UcmFuc2FjdGlvbih0cmFuc2FjdGlvbikge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHRoaXMucnVuV2l0aEd1YXJkKCgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBbc2lnbmVkVHJhbnNhY3Rpb25dID0geWllbGQgdGhpcy5wZXJmb3JtU2lnblRyYW5zYWN0aW9ucyhbdHJhbnNhY3Rpb25dKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2lnbmVkVHJhbnNhY3Rpb247XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzaWduQWxsVHJhbnNhY3Rpb25zKHRyYW5zYWN0aW9ucykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHRoaXMucnVuV2l0aEd1YXJkKCgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzaWduZWRUcmFuc2FjdGlvbnMgPSB5aWVsZCB0aGlzLnBlcmZvcm1TaWduVHJhbnNhY3Rpb25zKHRyYW5zYWN0aW9ucyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNpZ25lZFRyYW5zYWN0aW9ucztcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNpZ25NZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCB0aGlzLnJ1bldpdGhHdWFyZCgoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBhdXRoVG9rZW4sIHNlbGVjdGVkQWRkcmVzcyB9ID0gdGhpcy5hc3NlcnRJc0F1dGhvcml6ZWQoKTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy50cmFuc2FjdCgod2FsbGV0KSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLnBlcmZvcm1SZWF1dGhvcml6YXRpb24od2FsbGV0LCBhdXRoVG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgW3NpZ25lZE1lc3NhZ2VdID0geWllbGQgd2FsbGV0LnNpZ25NZXNzYWdlcyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkcmVzc2VzOiBbc2VsZWN0ZWRBZGRyZXNzXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXlsb2FkczogW21lc3NhZ2VdLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzaWduYXR1cmUgPSBzaWduZWRNZXNzYWdlLnNsaWNlKC1TSUdOQVRVUkVfTEVOR1RIX0lOX0JZVEVTKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzaWduYXR1cmU7XG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBXYWxsZXRTaWduTWVzc2FnZUVycm9yKGVycm9yID09PSBudWxsIHx8IGVycm9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlcnJvci5tZXNzYWdlLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2lnbkluKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5ydW5XaXRoR3VhcmQoKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3JlYWR5U3RhdGUgIT09IFdhbGxldFJlYWR5U3RhdGUuSW5zdGFsbGVkICYmIHRoaXMuX3JlYWR5U3RhdGUgIT09IFdhbGxldFJlYWR5U3RhdGUuTG9hZGFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFdhbGxldE5vdFJlYWR5RXJyb3IoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fY29ubmVjdGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXV0aG9yaXphdGlvblJlc3VsdCA9IHlpZWxkIHRoaXMucGVyZm9ybUF1dGhvcml6YXRpb24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBpbnB1dCksIHsgZG9tYWluOiAoX2EgPSBpbnB1dCA9PT0gbnVsbCB8fCBpbnB1dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW5wdXQuZG9tYWluKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB3aW5kb3cubG9jYXRpb24uaG9zdCB9KSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghYXV0aG9yaXphdGlvblJlc3VsdC5zaWduX2luX3Jlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2lnbiBpbiBmYWlsZWQsIG5vIHNpZ24gaW4gcmVzdWx0IHJldHVybmVkIGJ5IHdhbGxldFwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzaWduZWRJbkFkZHJlc3MgPSBhdXRob3JpemF0aW9uUmVzdWx0LnNpZ25faW5fcmVzdWx0LmFkZHJlc3M7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNpZ25lZEluQWNjb3VudCA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgKF9iID0gYXV0aG9yaXphdGlvblJlc3VsdC5hY2NvdW50cy5maW5kKGFjYyA9PiBhY2MuYWRkcmVzcyA9PSBzaWduZWRJbkFkZHJlc3MpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzOiBzaWduZWRJbkFkZHJlc3NcbiAgICAgICAgICAgICAgICAgICAgfSksIHsgcHVibGljS2V5OiB0b1VpbnQ4QXJyYXkkMShzaWduZWRJbkFkZHJlc3MpIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWNjb3VudDogc2lnbmVkSW5BY2NvdW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgc2lnbmVkTWVzc2FnZTogdG9VaW50OEFycmF5JDEoYXV0aG9yaXphdGlvblJlc3VsdC5zaWduX2luX3Jlc3VsdC5zaWduZWRfbWVzc2FnZSksXG4gICAgICAgICAgICAgICAgICAgICAgICBzaWduYXR1cmU6IHRvVWludDhBcnJheSQxKGF1dGhvcml6YXRpb25SZXN1bHQuc2lnbl9pbl9yZXN1bHQuc2lnbmF0dXJlKVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgV2FsbGV0Q29ubmVjdGlvbkVycm9yKChlIGluc3RhbmNlb2YgRXJyb3IgJiYgZS5tZXNzYWdlKSB8fCAnVW5rbm93biBlcnJvcicsIGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29ubmVjdGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVEZWZhdWx0QWRkcmVzc1NlbGVjdG9yKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHNlbGVjdChhZGRyZXNzZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFkZHJlc3Nlc1swXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgIH07XG59XG5cbmNvbnN0IENBQ0hFX0tFWSA9ICdTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyRGVmYXVsdEF1dGhvcml6YXRpb25DYWNoZSc7XG5mdW5jdGlvbiBjcmVhdGVEZWZhdWx0QXV0aG9yaXphdGlvblJlc3VsdENhY2hlKCkge1xuICAgIGxldCBzdG9yYWdlO1xuICAgIHRyeSB7XG4gICAgICAgIHN0b3JhZ2UgPSB3aW5kb3cubG9jYWxTdG9yYWdlO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZW1wdHlcbiAgICB9XG4gICAgY2F0Y2ggKF9hKSB7IH1cbiAgICByZXR1cm4ge1xuICAgICAgICBjbGVhcigpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFzdG9yYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgc3RvcmFnZS5yZW1vdmVJdGVtKENBQ0hFX0tFWSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1lbXB0eVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoX2EpIHsgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFzdG9yYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2Uoc3RvcmFnZS5nZXRJdGVtKENBQ0hFX0tFWSkpIHx8IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWVtcHR5XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChfYSkgeyB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0KGF1dGhvcml6YXRpb25SZXN1bHQpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFzdG9yYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgc3RvcmFnZS5zZXRJdGVtKENBQ0hFX0tFWSwgSlNPTi5zdHJpbmdpZnkoYXV0aG9yaXphdGlvblJlc3VsdCkpO1xuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZW1wdHlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKF9hKSB7IH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgIH07XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRXYWxsZXROb3RGb3VuZEhhbmRsZXIobW9iaWxlV2FsbGV0QWRhcHRlcikge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLmFzc2lnbihtb2JpbGVXYWxsZXRBZGFwdGVyLnVybCk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZURlZmF1bHRXYWxsZXROb3RGb3VuZEhhbmRsZXIoKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRXYWxsZXROb3RGb3VuZEhhbmRsZXI7XG59XG5cbmV4cG9ydCB7IFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXIsIFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJSZW1vdGUsIFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJSZW1vdGVXYWxsZXROYW1lLCBTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0TmFtZSwgY3JlYXRlRGVmYXVsdEFkZHJlc3NTZWxlY3RvciwgY3JlYXRlRGVmYXVsdEF1dGhvcml6YXRpb25SZXN1bHRDYWNoZSwgY3JlYXRlRGVmYXVsdFdhbGxldE5vdEZvdW5kSGFuZGxlciB9O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@solana-mobile+wallet-adapter-mobile@2.1.4_@solana+web3.js@1.98.0_bufferutil@4.0.8_utf-8-vali_jvmmv2csvzpookyrzhnufdtjlm/node_modules/@solana-mobile/wallet-adapter-mobile/lib/esm/index.js\n");

/***/ })

};
;